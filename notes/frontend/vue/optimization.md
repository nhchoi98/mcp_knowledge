---
title: 최적화
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# 최적화

# Virtual DOM 관련 최적화

네 가지는 Vue뿐만 아니라 **Virtual DOM 기반 프레임워크 전반의 최적화 핵심 규칙**이에요. 하나씩 자세히 설명해드릴게요.

# 1) DOM이 “같은 노드인지” 판단하는 기준

- Vue는 **`type + key`*로 노드 동일성을 판단해.
- **같은 key면 같은 엔티티**로 보고 *“patch(업데이트)”*,
- **key가 다르면 다른 엔티티**로 보고 *“unmount + mount(교체)”*.

### index를 key로 쓰면 생기는 문제

- 데이터가 **앞에서 삭제/삽입/정렬**되면 **index가 연쇄적으로 바뀜**.
- 결과적으로 Vue는 *A의 DOM을 B에 재사용*하거나 *여러 노드를 교체*해 버릴 수 있어.
- 부작용:
    - **불필요한 재생성**(unmount/mount) 증가 → 성능 저하
    - **상태/포커스/입력 값**이 다른 아이템으로 섞여 들어감 (예: 인풋 커서가 튐)

# 2) 인라인 객체/함수 지양 — 왜 참조를 고정해야 하나?

### 문제의 본질: 참조가 매 렌더마다 새로 생김

- 템플릿 안의 리터럴 `{}` / `[]` / `() => {}` 는 **렌더마다 새 인스턴스**.
- 비교는 **참조 동등성**으로 하므로, 내용이 같아도 “다른 값”으로 인식.

### 어디서 비용이 튀나?

1. **자식 props로 내려갈 때**
    - 부모가 `:style="{ color: isRed ? 'red' : 'blue' }"`처럼 리터럴을 넘기면,
        
        자식은 **매 렌더마다 “props 변경”**으로 인식 → 자식 *update* 스케줄.
        
    - 내용이 같아도 **불필요한 업데이트 경로**를 한 번 더 탐.
2. **스타일/클래스 패치**
    - `:style="{...}"`, `:class="{...}"` 는 매번 **새 객체 정규화(normalize) + diff**가 필요.
    - 값이 같아도 객체가 새참조 → **패치 로직 진입 + 비교 비용/GC 압력** 증가.
3. **이벤트 핸들러**
    - `@click="() => doSomething(id)"`는 매 렌더마다 **새 함수**.
    - Vue 3는 이벤트 패치 최적화(Invoker 업데이트)로 add/remove는 피하지만,
        
        **새 함수 할당 + 클로저 캡처 비용**은 그대로 발생.
        
    - 특히 **핸들러를 props로 자식에게 넘길 때**는 완전한 **참조 변경 → 자식 업데이트**로 이어짐.

### 해결 패턴

- **상수/캐시**로 빼서 **참조 고정**:

## **동적 객체가 필요하면 `computed`로 메모**:

# 3) `v-if` vs `v-show` — 어떤 “DOM 비용”이 드나?

### `v-if` (생성/해제)

- **false → true**:
    - VNode 생성 → **실제 DOM 노드 create/insert**
    - 속성/스타일/이벤트 **바인딩**
    - **컴포넌트면** 인스턴스 생성, `setup`/`onBeforeMount`/`onMounted`
    - 반응형 **effect/watch 등록**
    - 초기 레이아웃/페인트
- **true → false**:
    - 타이머/구독/옵저버 **해제**
    - **컴포넌트 unmount**, `onUnmounted`
    - 이벤트 핸들러 제거, DOM **remove**
- 요약: **마운트/언마운트 풀사이클** = 비용 큼, 하지만 **메모리/리스너/워처가 완전히 사라짐**(유휴 시 0에 수렴).

### `v-show` (표시/숨김)

- DOM은 **항상 존재**, `display: none` 토글만.
- 토글 시:
    - **스타일 재계산** + **레이아웃(reflow)** 영향 범위만큼
    - 페인트/합성 단계 갱신
- 컴포넌트/워처/타이머는 **살아 있음**(언마운트가 아님)
- 요약: **토글 비용 작음**(CSS 변경) 대신 **메모리/구독/타이머가 계속 점유**.

1. 무거운 화면을 자주 왕복 → `<KeepAlive>` + `:max` + 조건부 리프레시 전략.

## Page / Component 개수가 많을 때 발생하는 비용

- **초기 로딩**
    - 모든 컴포넌트를 한 번에 import하면 번들 사이즈 커짐 → 초기 다운로드·파싱·실행 비용 ↑
    - 특히 라우트별로 안 쓰는 페이지까지 한 번에 로딩하면 낭비.
- **렌더링 사이클**
    - “많다”보다 **실제로 동시에 렌더링되는 수**가 중요.
    - 보이지 않는 컴포넌트까지 렌더링하거나 갱신되면 CPU/GPU 낭비.
- **메모리 점유**
    - 언마운트되지 않고 계속 메모리에 남는 컴포넌트가 많아지면 브라우저 메모리 사용량↑.
    - 특히 `<KeepAlive>` 남발 시 발생.

---

## 2. 무분별한 재사용/비재사용이 문제인 이유

- **무분별하게 재사용되지 않음**
    
    → 같은 구조라도 새 인스턴스가 계속 만들어짐 → 불필요한 mount/unmount 비용 ↑
    
    → 내부적으로 워처/이벤트 핸들러/구독 객체가 계속 붙었다 떨어지면서 GC 압박.
    
- **무분별하게 재사용됨**
    
    → `<KeepAlive>`로 남발 캐시 → 필요 없는 상태까지 메모리에 유지 → 메모리 낭비 및 오래된 데이터(stale) 문제.
    

# unplugin-vue-router와 Lazy loading route

- 실제 페이지에 접근할 때 해당 DOM을 FETCH 해옴
- Unplugin Vue는 이 설정이 Default로 들어가있음

```jsx
{
  path: '/about',
  component: () => import('@/pages/about.vue') // 동적 import
}
```

# 가상스크롤

Vue 같은 프레임워크에서 **많은 양의 리스트(수천~수만 개)를 DOM에 모두 렌더링하지 않고, 화면(Viewport)에 보이는 일부만 그려주는 기법**이에요.

## 1. 왜 필요한가?

- 브라우저는 DOM 노드가 많아질수록 **렌더링·레이아웃 계산·메모리 관리**에 큰 비용을 씁니다.
- 예: `<li>` 10,000개를 한 번에 렌더링 → DOM 트리/스타일 계산/레이아웃만으로도 성능이 급격히 느려짐.
- 하지만 실제로 사용자가 보는 건 **스크롤 위치 근처 몇십 개뿐**.

👉 “보이는 부분만 그려주고, 스크롤할 때 필요한 부분만 갈아끼우자” → **가상 스크롤**

---

## 2. 동작 원리

1. **전체 리스트 높이 계산**
    - 가상 스크롤 컨테이너는 스크롤바를 유지하기 위해 전체 아이템의 “총 높이”를 가짜로 만들어 둡니다.
    - 예: 아이템 10,000개 × 30px = 300,000px 높이의 가짜 div.
2. **뷰포트 범위에 해당하는 아이템만 렌더링**
    - 스크롤 위치를 계산해서 지금 보여야 할 인덱스 구간만 DOM에 올립니다.
    - 예: 화면에 20개만 보이면, 실제 DOM에는 20~40개 정도만 존재.
3. **위/아래 공간을 placeholder로 채우기**
    - 아직 보이지 않는 아이템 영역은 빈 div로 높이만 채워 스크롤바 위치가 정확히 맞도록 함.
4. 장점
- 대규모 데이터도 **부드러운 스크롤** 유지
- 메모리 사용량 ↓ (DOM 노드 수 최소화)
- 초기 렌더링 속도 ↑

# Debounce 적용

검색 시 결과 띄울 때 입력할때마다 쿼리 요청 날라가는거 방지하기 위해서 Debounce적용