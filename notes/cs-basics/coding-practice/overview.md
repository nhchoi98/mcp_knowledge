---
title: 코딩테스트 준비
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# 코딩테스트 준비

[https://fern-freeze-290.notion.site/38-2025-3c6c9b4b2ccd4250b649762e12fc64e0](https://www.notion.so/3c6c9b4b2ccd4250b649762e12fc64e0?pvs=21)

[http://skmouse.tistory.com/entry/코딩테스트-공부방법?utm_source=chatgpt.com](http://skmouse.tistory.com/entry/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B3%B5%EB%B6%80%EB%B0%A9%EB%B2%95?utm_source=chatgpt.com)

[https://www.techinterviewhandbook.org/best-coding-interview-courses/?utm_source=chatgpt.com](https://www.techinterviewhandbook.org/best-coding-interview-courses/?utm_source=chatgpt.com)

# 큰 준비의 관점

## 마음가짐

1. 어떻게하면 Javascript 답게 풀어낼 수 있을까? 
2. 수준높은 개발자가 될 수 있는 계기로 만들어야함 

## 공부 방법

1. 시간복잡도 계산하기
2. 알고리즘과 자료구조를 알자 

## 문제푸는 방식

## 내가 이 유형 이해했어! 할 수 있을때

1. 하나의 유형에 대해 해설을 보고 이해할 때 
2. 하나의 유형에 대해 해설 없이 정답 코드만 보고도 이해할 때 
3. 하나의 유형에 대해 답을 보지 않고도 해결할 수 있을 때 
4. 문제의 유형을 모른 채로 보고도 문제를 해결할 수 있는 여러 풀이를 떠올릴 수 있을때 
5. 시간 복잡도와 구현 복잡도를 고려해 문제에 대한 효율적인 풀이를 선택할 수 있을 때

# 풀이 패턴

## 투 포인터 알고리즘 (Two Pointers)

- **개념**: 정렬된 배열이나 리스트에서 두 개의 포인터(인덱스)를 양쪽 끝(또는 특정 위치)에 두고, 조건에 따라 움직이며 문제를 해결하는 방식.
- **사용 예시**:
    - 정렬된 배열에서 합이 특정 값이 되는 두 원소 찾기
    - 중복 제거 (정렬된 배열에서 unique 값들만 추출) → 애너그램 문제에서도 같은 풀이 적용 가능
    - 병합 과정(merge sort의 병합 단계)
- **장점**:
    - 모든 경우의 수를 일일이 탐색하지 않고, 한 번의 선형 탐색(`O(n)`)으로 해결 가능.

```jsx
function twoSum(arr, target) {
  let left = 0, right = arr.length - 1;
  while (left < right) {
    const sum = arr[left] + arr[right];
    if (sum === target) return [left, right];
    if (sum < target) left++;
    else right--;
  }
  return [];
}
```

## **Multiple Pointers Pattern (다중 포인터 패턴)**

- **개념**: 꼭 양쪽 끝에서 출발하는 투 포인터가 아니어도, **여러 개의 포인터**를 사용해서 서로 다른 위치에서 데이터를 동시에 탐색/비교하는 기법.
- **투 포인터의 확장판**이라고 볼 수 있음.
- **사용 예시**:
    - 문자열 비교 (예: 두 문자열이 아나그램인지 확인할 때 각 문자 카운트를 비교)
    - 세 수의 합 문제 (3Sum → 세 포인터 조합)
    - 배열 내 양수/음수 분리
- **장점**:
    - 문제 상황에 따라 포인터를 유연하게 배치 가능 → 브루트포스(`O(n^2)`나 `O(n^3)`)보다 효율적.

## **Sliding Window Pattern (슬라이딩 윈도우 패턴)**

- **개념**: 배열이나 문자열에서 **연속된 구간(subarray, substring)**의 문제를 풀 때, "윈도우"를 한 칸씩 이동시키며 최소한의 연산으로 결과를 갱신하는 기법.
- **사용 예시**:
    - 연속된 부분합 (예: 길이가 k인 부분 배열의 최대 합)
    - 문자열 내 특정 조건 만족하는 최소/최대 길이 서브스트링
    - 중복 없는 가장 긴 서브스트링 찾기
- **장점**:
    - 불필요하게 전체 합/조건을 다시 계산하지 않고, 앞뒤 원소만 더하고 빼는 방식으로 최적화 (`O(n)`).

---

# 언제 쓰나?

- 답이 **연속 구간**일 때: subarray / substring
- 조건이 “**at most/at least K**”, “**합 ≥ K**”, “**종류 ≤ K**”, “**모두 포함**(Minimum Window)” 처럼 **윈도우 상태로 판정** 가능할 때
- 배열이 **양수만**일 때 합/곱 조건을 쉽게 다룸 (음수가 섞이면 프리픽스/모노톤 덱 같은 변형 필요)

# 기본 패턴

```jsx
let left = 0;
for (let right = 0; right < n; right++) {
  // 1) 오른쪽 확장: 윈도우에 nums[right] / s[right] 추가
  // 2) 조건 위반이면 왼쪽을 줄이며 불변식 회복
  while (/* 조건 위반 */) {
    // nums[left] / s[left] 제거
    left += 1;
  }
  // 3) 정답 갱신 (최장/최단/개수 등)
}

```

- **확장 → 필요 시 축소 → 갱신** 순서가 정석
- 축소는 보통 `while` (한 번에 여러 칸 줄일 수 있음)

---

# 해시맵

해시 함수를 사용하여 고유한 키를 배열의 인덱스(버킷)로 변환합니다. 이를 통해 평균적으로 O(1)의 빠른 검색, 삽입, 삭제 시간을 제공하지만, 해시 충돌 시 성능이 저하될 수 있어 충돌 해결 알고리즘이 함께 사용됩니다. 

# 우선순위큐

가장 우선순위가 높은(혹은 낮은) 원소”를 빠르게 꺼내기 위한 자료구조예요. 보통 **이진 힙(binary heap)**으로 구현하고, 핵심 연산의 시간복잡도는 다음과 같습니다.

- `push`(삽입) : `O(log n)`
- `pop`(가장 우선 원소 꺼내기) : `O(log n)`
- `peek`(가장 우선 원소 조회) : `O(1)`

### 언제/어떻게 쓰나 (문제 푸는 방식)

1. **우선순위 정의**
    
    “무엇이 더 먼저 나와야 하는가?”를 비교함수로 정합니다.
    
    - 최단거리 → 거리 작은 게 우선(최소 힙)
    - 스케줄링/회의실 → 가장 빠른 **종료시간**이 우선(최소 힙)
    - Top-K 큰 값만 유지 → 값 작은 게 우선인 **크기 K의 최소 힙**에 담고, 넘치면 팝
2. **루프 구조**
    - 초기 후보들을 큐에 `push`
    - 큐가 빌 때까지 `pop` → “가장 좋은” 후보를 꺼내 처리
    - 처리 중 생기는 새로운 후보를 다시 `push`
    - 중복/낡은 상태는 `visited`나 최신성 체크로 스킵
3. **전형 문제들**
    - **다익스트라 최단경로**: (거리, 정점) 최소 힙
    - **회의실 배정(최소 회의실 수)**: 끝나는 시간 최소 힙
    - **K개 정렬 배열 병합**: (값, 배열번호, 인덱스) 최소 힙
    - **스트리밍 Top-K**: 크기 K의 힙 유지
    - **허프만 코딩**, **작업 스케줄링** 등
- *핵심은 “우선순위를 비교함수로 명확히 정의”**하는 것.
- 그 다음은 **가장 우선인 후보를 반복적으로 꺼내서 확장**하는 루프.
- 많은 그리디/그래프/스케줄링 문제가 PQ로 `O(n log n)` 또는 `O((n+m) log n)`에 깔끔하게 풀립니다.

## 크로노 스위핑

# Frequent counter pattern

Frequency Counter 패턴은 일반적인 알고리즘 패턴 중 하나로, 두 배열이나 문자열이 동일한 구성 요소를 가지고 있는지를 판단할 때 유용하다. 이 패턴은 객체나 집합(Set)을 사용하여 배열이나 문자열의 값을 수집하고, 그 값들의 빈도를 기록하여, 두 배열 또는 문자열이 동일한 구성 요소를 가지고 있는지 비교한다.

이 패턴을 이용하면, 중첩 반복문이나 O(N^2) 시간 복잡도의 연산을 피할 수 있어 성능을 향상 시킬 수 있다.

# DFS

# BFS

# DP

## 다익스트라 알고리즘

## 브루트포스

[프로그래머스 ](%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%A4%80%EB%B9%84/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20277cee38e89a802483a0ea6a0f95a79a.md)