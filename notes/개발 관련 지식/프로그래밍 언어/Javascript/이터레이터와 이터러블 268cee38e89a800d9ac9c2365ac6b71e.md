---
title: 이터레이터와 이터러블
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# 이터레이터와 이터러블

# 이터러블과 이터레이션

## 이터러블 **(Iterable)**

> "반복 가능한 객체" → 즉, for..of 문이나 스프레드 연산자(...)에 쓸 수 있는 객체
> 
- 조건: 반드시 `@@iterator` 메서드를 가져야 함 (`Symbol.iterator`라는 특별한 키)
- 대표적인 이터러블: **Array, String, Map, Set, arguments, NodeList 등**

# 이터레이터  **(Iterator)**

> "이터러블을 순회할 때 실제 동작하는 객체"
> 
- 규칙: `next()` 메서드를 가지고 있어야 하고,
    
    `next()`는 `{ value: 값, done: 불리언 }` 객체를 반환해야 함.
    
    ## **이터레이션 프로토콜**
    
    ES6에서 정의한 약속 두 가지:
    
    1. **이터러블 프로토콜**
        - 객체가 `Symbol.iterator` 메서드를 구현해야 함
        - 이 메서드가 이터레이터 객체를 반환해야 함
    2. **이터레이터 프로토콜**
        - 이터레이터 객체는 `next()` 메서드를 가져야 하고, `{ value, done }`을 반환해야 함

# **Symbol.iterator**

`Symbol.iterator`는 **ES6에서 도입된 특별한 심볼(Symbol) 프로퍼티**로, **객체를 이터러블(Iterable)하게 만들어주는 핵심 키**입니다. 이걸 이해하려면 "이터러블 프로토콜"과 "프로토타입" 개념이 연결됩니다.

`Symbol.iterator`는 객체의 **프로토타입 체인**에 정의되어 있습니다.

즉, 배열, 문자열, 맵, 셋 등은 각각 자기 프로토타입에 `Symbol.iterator` 메서드를 구현해두었기 때문에 이터러블로 동작할 수 있습니다.

즉, 배열은 자신의 프로토타입인 **`Array.prototype`**에 `Symbol.iterator`라는 메서드가 정의되어 있어서 반복 가능(Iterable)합니다.