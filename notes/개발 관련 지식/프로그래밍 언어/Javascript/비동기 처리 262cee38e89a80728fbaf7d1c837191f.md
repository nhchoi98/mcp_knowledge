---
title: 비동기 처리
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# 비동기 처리

- 자바스크립트는, 단 하나의 실행 컨텍스트 스택을 가짐. 즉, 싱글 스레드 구조로 동작함
- 비동기처리란, 현재 실행중인 태스크가 종료되지 않은 상태라고 해도 다음 태스크를 곧바로 실행하는 방식을 의미한다.

# Promise

비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다. 이는 이벤트 루프의 특징에 기반하는데, 따라서 후속 처리는 비동기 함수 내부에서 처리해야한다. 이 때 필연적으로 callback 지옥이 생성될 수 있는데, 이를 해결하기 위해 등장한 개념이 Promise이다.

## Then

fulfilled 시 호출되는 callback

## Catch

reject시 호출되는 callback

## Finally

상태 변화가 일어나면 무조건 호출됨. 

## Promise.all과 race , allSettled

all은 모두 끝났을 때 그 결과를 배열로 반환 

race는 젤 빨리 끝난거 resolve/reject 하는 Promise 반환 

allSettled는 fulfilled되면 모두 반환 

## Fetch

프로미스를 리턴 형태로 반환 

다만, 주의할 점은 CORS나 네트워크 장애가 아니면 then으로 처리되기 때문에 HTTP Status에 따라 다르게 처리해주어야함 

# Async, Await

## 제너레이터

함수의 한 종류. 코드 블록을 실행하는것이 아닌, 제너레이터 객체를 생성해 반환한다. 

제너레이터는 이터러블이면서 이터레이터이다. 

## Yield

제너레이터 함수의 실행을 일시 중지시키거나 Yield 키워드 뒤에 오는 표혀신식의 평가 결과를 제너레이터 함수 호출자에게 반환한다. 표현식이 실행될 때는 변수에 값이 이 시점에 할당되지 않고, 그 다음 호출 시 할당된다. 

## Next

value, done 프로퍼티를 갖는 이터레이터 Result 객체를 반환한다. 

## 무한 이터러블

## Async/await

마치 동기 처리처럼 프로미스를 사용할 수 있는 개념 

async 함수는 암묵적으로 반환값을 resolve 하는 프로미스를 반환함.

await는 settled 상태가 될 때 까지 대기하다가, 프로미스가 resolve 한 처리 결과를 반환한다. 

반드시 Promise 앞에 사용해야 한다. 

`await`는 사실상 `Promise.then`을 **문법적으로 깔끔하게 표현한 것**입니다

- `await expr`에서 expr이 Promise가 아니라면 → 자동으로 `Promise.resolve(expr)`로 래핑됩니다.
- `throw`는 내부적으로 `Promise.reject(...)`와 동일하게 처리돼요.
- 현재 실행 중인 `async` 함수의 실행 컨텍스트는 **일시 중단(suspended)** 상태가 됩니다.
    
    즉, 동기 코드 실행을 마친 뒤 **마이크로태스크 큐(Microtask Queue)**에 `.then` 체인이 등록됩니다.
    
- 이벤트 루프가 돌면서 해당 Promise가 **settled(fulfilled/rejected)** 상태가 되면,
    
    등록된 콜백이 실행되면서 중단된 지점 이후 코드가 이어집니다.
    
- `async` 함수는 **반환값을 무조건 Promise로 감싼다**.
- `await`는 실행 컨텍스트를 **일시 중단(suspend)** 시키고, Promise가 settle될 때까지 이벤트 루프에게 제어권을 넘긴다.
- 그 후 실행 컨텍스트가 다시 **재개(resume)** 되면서 마치 동기처럼 보이게 동작한다.

| 구분 | Promise | async/await |
| --- | --- | --- |
| 코드 스타일 | 체이닝(`.then`) 중심 | 동기식 코드처럼 직관적 |
| 에러 처리 | `.catch()` | `try...catch` |
| 가독성 | 체인이 길면 복잡 | 간결하고 읽기 쉬움 |
| 병렬 처리 | `Promise.all` 등 쉽게 활용 | `Promise.all` 같이 써야 병렬 처리 |
| 학습 난이도 | 조금 더 복잡 | 더 직관적, 초보자 친화적 |

## Async/await의 병렬 처리

```jsx
async function main() {
try {
// 병렬 실행
const [user, settings] = await Promise.all([fetchUser(), fetchSettings()]);

```
console.log("User:", user);
console.log("Settings:", settings);

```

} catch (err) {
console.error("Error:", err);
}
}
```

## 이벤트 루프와 태스크 큐

HTTP 요청, 이벤트 핸들러는 비동기 방식으로 처리함 

자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프이다. 

크게 스택과 힙 영역으로 구분되어 있음 

## 태스크 큐

setTimeout, setInterval, HTTP 요청, 이벤트 핸들러와 같이 비동기 함수의 콜백함수 또는 이벤트 핸들러가 일시적으로 보관되는 곳. 

## 마이크로 태스크 큐

프로미스의 콜백 함수가 일시적으로 보관되는 곳. 실행 순서가 마이크로 태스크 큐 보다 높다.  

## 이벤트 루프

콜 스택에 현재 실행중인 실행 컨텍스트가 있는지, 태스크큐에 대기중인 함수가 있는지를 반복적으로 확인하는것.