---
title: 이벤트 관련
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# 이벤트 관련

# 이벤트 루프

## 이벤트 타입

MDN Event reference 에서 확인이 가능함.  이벤트의 종류를 나타내는 문자열 

## 이벤트 드리븐 프로그래밍

프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍이라 한다. 

## 이벤트 핸들러

특정 타입의 이벤트가 발생했을 때, 호출될 함수를 이벤트 핸들러라고 한다. 

## 이벤트 전파

자바스크립트의 **이벤트 전파(Event Propagation)**는 DOM 트리 구조에서 이벤트가 전달되는 과정으로, 크게 **캡처링(Capturing) → 타깃(Target) → 버블링(Bubbling)** 단계로 동작합니다.

### 이벤트 캡처링

- 이벤트가 최상위 객체(`window` → `document` → `<html>` → `<body>` …)에서 시작해서 **이벤트 발생 요소까지 내려가는 단계**입니다.
- 이벤트 리스너를 `addEventListener("click", handler, true)`처럼 **세 번째 인자에 `true`*를 주면 캡처링 단계에서 이벤트를 감지할 수 있습니다.

### 타깃 단계

- 이벤트가 **실제로 발생한 요소(`event.target`)**에 도달하는 단계입니다.
- 이때 해당 요소에 등록된 이벤트 핸들러가 실행됩니다.

### 이벤트 버블링

- 이벤트가 발생한 요소에서 다시 상위 요소로 **거꾸로 전파되는 단계**입니다.
- 기본적으로 `addEventListener`의 세 번째 인자가 `false`이거나 생략된 경우, 이벤트는 버블링 단계에서 실행됩니다.
- 이벤트 위임(Event Delegation)은 이 버블링 단계의 특성을 활용합니다.

### 제어방법

- **`event.stopPropagation()`**: 전파를 중단합니다. (다른 상위 요소까지 전달되지 않음)
- **`event.stopImmediatePropagation()`**: 같은 요소에 등록된 다른 이벤트 핸들러까지도 실행되지 않게 막습니다.
- **`event.preventDefault()`**: 전파와는 별개로, 브라우저 기본 동작을 막습니다.

## 이벤트 위임

이벤트 위임(Event Delegation)은 **하위 요소 각각에 이벤트 리스너를 붙이지 않고, 상위 요소에 한 번만 이벤트 리스너를 등록해서 이벤트 버블링을 활용하는 패턴**입니다.

- **메모리 효율**: 많은 자식 요소 각각에 핸들러를 붙이지 않아도 되므로 성능적으로 유리합니다.
- **동적 요소 처리**: 자식 요소가 DOM에 동적으로 추가/삭제되더라도, 상위에 걸린 리스너는 계속 동작하기 때문에 유지보수가 편합니다.
- **코드 단순화**: 반복되는 리스너 등록 코드를 줄일 수 있습니다.

## 마우스 이벤트

### 버블링 되는 이벤트

mouseover

## 키보드 이벤트

## 포커스 이벤트

## 폼 이벤트

## 값 변경 이벤트

## DOM 조작

## 이벤트 핸들러 어트리뷰트 방식

- HTML 태그의 속성을 통해 자바스크립트 코드를 직접 작성하여 이벤트가 발생했을 때 특정 동작을 수행하도록 정의하는 방식
- ex) onclick, onmouseover
- 스코프는 전역 스코프 대상임
- HTML 안에 JS 문자열을 직접 넣으므로, **XSS 공격**에 취약합니다.

```jsx
<button onclick="alert('클릭!')">클릭하세요</button>

<input type="text" oninput="console.log(this.value)" />
```

## 이벤트 핸들러 프로퍼티 방식

**HTML 요소 객체의 프로퍼티에 직접 이벤트 핸들러를 할당하는 방법**이에요.

```jsx
const btn = document.getElementById("myBtn");
btn.onclick = function () {
  alert("버튼 클릭됨!");
};
```

## AddEventListener 매서드 방식

- EventTarget.prototype.addEventListener 매서드 사용
- addEventListener(이벤트명, 콜백, 옵션)

```jsx
element.addEventListener(type, listener [, options]);
```

- **type**: `"click"`, `"input"`, `"mouseover"` 같은 이벤트 이름 (접두어 `on` 없음).
- **listener**: 이벤트 발생 시 실행할 함수.
- **options**(선택): 이벤트 동작 제어 객체 (예: `{ capture: true, once: true, passive: true }`).
- **여러 핸들러 동시 등록 가능**
    - 같은 이벤트에 여러 개의 리스너를 붙일 수 있어 유연함.
- **이벤트 전파 제어 가능**
    - 옵션으로 **캡처링 단계**에서 실행할지, **버블링 단계**에서 실행할지 지정 가능.

```jsx
element.addEventListener("click", handler, { capture: true });
btn.addEventListener("click", (event) => {
  console.log("다른 핸들러도 실행됨!");
  event.stopPropagation(); // 이벤트 전파 중단
});
```

| 구분 | 어트리뷰트 | 프로퍼티(L0) | addEventListener(L2) |
| --- | --- | --- | --- |
| 가독성/분리 | ❌ (HTML에 JS 섞임) | ⭕ | ⭕⭕ |
| 다중 핸들러 | ❌ | ❌ | ⭕ |
| 옵션 (once/passive/capture) | ❌ | ❌ | ⭕ |
| 해제 난이도 | N/A | ⭕(null 대입) | △(같은 참조 필요) |
| 이벤트 위임/성능 | ❌ | △ | ⭕ |
| 호환성 | ⭕ | ⭕ | ⭕ (현대 브라우저) |
| 보안(CSP/XSS) | ❌ (inline, 취약) | ⭕ | ⭕⭕ |

# 관련 WEB API(DOM API)

브라우저가 제공하는 **자바스크립트 프로그래밍 인터페이스**로, DOM 트리에 접근하고 수정할 수 있도록 해주는 도구.

- ECMAScript(순수 JS 문법) 스펙에 정의된 게 아니라,
    
    **브라우저 환경이 자바스크립트 엔진 위에 제공하는 API** 중 하나예요.
    
- 즉, 자바스크립트 엔진(V8, SpiderMonkey 등)만으로는 `addEventListener`를 실행할 수 없고, **브라우저의 DOM API** 또는 Node.js 같은 환경에서 제공해야 사용할 수 있습니다.
- 이벤트 리스너(핸들러)를 등록하는 표준적인 방법

# Debounce와 Throttle

## requestAnimationFrame(rAF)을 활용한 스크롤 이벤트 최적화 기법

### 왜 필요한가?

- `scroll` 이벤트는 사용자가 스크롤을 움직일 때마다 **매우 자주** 발생합니다. (초당 수백 번 이상)
- 이 이벤트 안에서 무거운 계산이나 DOM 조작을 하면 브라우저가 버벅이고, 프레임 드롭이 생길 수 있어요.
- 그래서 **“너무 자주 실행되는 이벤트를 적당히 줄이는”** 스로틀(throttle) 기법이 필요합니다.

---

### `requestAnimationFrame`이란?

- 브라우저가 **다음 화면을 그리기 직전**에 콜백을 실행시켜주는 Web API.
- 보통 초당 60fps 환경이라면 약 **16.7ms마다 1번** 실행됩니다.
- 따라서 `scroll` 이벤트마다 함수가 호출되는 대신, **한 프레임에 최대 1번만 실행되도록 보장**할 수 있어요.
- **`setTimeout` 기반 스로틀**: 일정 시간(예: 100ms)에 한 번 실행 → 시간 단위 제어.
- **`rAF 스로틀`**: 화면 리프레시 타이밍(16.7ms 기준)에 맞춰 실행 → **렌더링과 싱크**가 맞아 애니메이션/스크롤에 특히 적합.

## Throttle vs Debounce

- **Throttle (쓰로틀)**
    
    → “일정 주기마다 한 번만 실행”
    
    → 예: `scroll` 이벤트를 100ms마다 실행 → **주기적 제한**
    
- **Debounce (디바운스)**
    
    → “마지막 호출 이후 일정 시간이 지나야 실행”
    
    → 예: `input`에 타이핑이 멈추고 500ms 동안 더 입력이 없을 때만 실행 → **최종 이벤트만 실행**
    

👉 목적이 달라요:

- Throttle: 빈도 줄이기 (주기적으로 실행 유지)
- Debounce: 이벤트 폭주 방지 (마지막만 실행)

# XSS

- 웹 애플리케이션이 사용자 입력을 제대로 검증/필터링하지 않고 그대로 출력할 때 발생하는 취약점.
- 공격자가 악성 스크립트를 삽입해 다른 사용자의 브라우저에서 실행되게 만드는 기법.

# CSP

- 브라우저가 **어떤 리소스를 불러올 수 있는지 제약하는 보안 헤더**.
- XSS와 같은 코드 인젝션 공격을 막는 데 효과적.

# CSRF

- 사용자가 로그인된 상태에서, 공격자가 **의도치 않은 요청을 서버에 보내도록 유도**하는 공격.
- 예: 은행 사이트에 로그인한 상태에서, 공격자가 만든 페이지에 접속 → 자동으로 송금 요청 전송.

| 구분 | XSS | CSP | CSRF |
| --- | --- | --- | --- |
| 성격 | 취약점(공격 기법) | 방어 정책(브라우저 보안 헤더) | 취약점(공격 기법) |
| 초점 | 악성 스크립트 삽입·실행 | 허용된 리소스만 로드 | 인증된 사용자의 권한을 악용 |
| 주요 피해 | 세션 탈취, 피싱, 악성 요청 | XSS 차단, 무단 리소스 로드 방지 | 계좌 이체, 게시글 등록, 권한 변경 등 |
| 대응책 | 입력값 검증, 이스케이프 처리, CSP | 서버에서 헤더 설정 | CSRF 토큰, SameSite 쿠키 |

| 구분 | getElementById | querySelector |
| --- | --- | --- |
| 입력값 | `id` 문자열만 | 모든 CSS 선택자 |
| 기호 필요 여부 | `"myId"` (그냥 이름) | `"#myId"` (`#` 포함) |
| 반환 | 1개 요소 | 첫 번째 요소 |
| 반환 없을 시 | `null` | `null` |
| 성능 | 더 빠름 (최적화) | 약간 느림 |
| 유연성 | 한정적 | 매우 유연 |