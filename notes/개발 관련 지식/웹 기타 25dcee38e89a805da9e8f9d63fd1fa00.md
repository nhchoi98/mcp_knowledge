---
title: 웹 기타
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# 웹 기타

# SPA (Single Page application)이란?

페이지 전체를 다시 받지 않고, 한 번 받은 페이지 안에서 자바스크립트로 화면을 바꿔 가는 방식”**이야. 서버는 주로 **데이터(JSON)**만 주고, **라우팅·렌더링은 브라우저(클라이언트)**가 맡아

# 무한스크롤

# 핵심 기능

- **엔트리 → 모듈 그래프 생성**: `import/require` 해석, alias/외부화(external) 처리
- **코드 스플리팅**: `import()` 기준으로 **동적 청크** 생성, **공유 청크**(vendor) 분리
- **트리 쉐이킹**: ESM 기반 **미사용 코드 제거**(sideEffects 플래그/순수성 분석)
- **최적화**: 난독/압축(minify), dead-code 제거, 인라인/자산 최적화
- **에셋 파이프라인**: CSS 병합/추출(CSS code-split), 이미지/SVG/웹폰트 처리
- **HMR/Dev Server**: 개발 시 **빠른 피드백**(프레임워크 통합)
- **소스맵/코스플릿 힌트**: `preload/prefetch` 링크, 청크 해시(`contenthash`)

## 컴파일러와 인터프리터의 차이는 무엇인가요?

- **컴파일러**: 소스 코드를 **사전에** 다른 형식(보통 **기계어/바이트코드**)로 변환 → 그 결과물을 실행
- **인터프리터**: 소스(또는 바이트코드)를 **실행 시점**에 **직접 읽고** 한 줄/한 명령씩 수행

# Lint란?

'lint'는 **소프트웨어 개발에서 소스 코드를 분석하여 오류, 버그, 스타일 위반 등을 찾아내는 도구**를 의미하거나, 또는 그러한 도구를 사용하는 행위인 '린팅(Linting)'을 뜻합니다. 린팅 도구는 마치 건조기의 린트 트랩이 섬유는 걸러내고 폐기물만 포집하듯, 코드에서 불필요한 부분이나 잠재적 문제를 찾아 교정하는 역할을 합니다. 

## 쓰로틀링이란?

- *Throttle(스로틀링)**은 함수 호출 빈도를 **일정한 간격으로 제한하는 기법**이에요.

즉, 이벤트가 매우 자주 발생하더라도(예: 스크롤, 마우스 이동), 지정한 간격(ms) 안에서는 **최대 한 번만 실행**되도록 보장하는 거죠.

---

## 🟢 예시로 이해하기

- **상황**: 스크롤 이벤트는 초당 수십~수백 번 발생할 수 있어요.
- **문제**: 이걸 그대로 실행하면 DOM 연산이나 API 호출이 과도하게 발생 → 성능 저하.
- **해결**: `throttle(fn, 200)` 을 걸면 → 스크롤 이벤트가 아무리 빨라도 **200ms마다 한 번만** 실행됨.

# 웹 소켓

**브라우저와 서버가 양방향(Full-duplex)으로 실시간 통신**을 할 수 있게 해주는 프로토콜이에요. WebSocket = **HTTP 기반 초기 연결 후, 서버와 클라이언트가 실시간·양방향으로 자유롭게 데이터 교환**할 수 있는 프로토콜.

- WebSocket은 HTTP로 **초기 연결(handshake)**을 맺은 뒤,
    
    **지속적인 TCP 연결**을 유지하면서 클라이언트 ↔ 서버가 자유롭게 메시지를 주고받을 수 있게 해줍니다.
    
- 즉, 서버가 원할 때 클라이언트에 데이터를 푸시할 수 있고, 클라이언트도 별도 요청 없이 메시지를 전송할 수 있어요.
- 브라우저 → 서버에 WebSocket 연결 요청 (HTTP Upgrade 헤더 포함).
- 서버가 수락하면 HTTP 연결이 WebSocket 연결로 업그레이드됨.
- 이후에는 **지속 연결 상태에서 양방향 데이터 교환**.
- ✅ WebSocket은 **HTTP/1.1 시절부터 지원**됐고, 지금도 HTTP/1.1 업그레이드로 동작 가능.

## 활용 사례

- 실시간 채팅 (예: 카카오톡 웹, Slack, Discord)
- 주식/코인 시세 스트리밍
- 온라인 게임 네트워킹
- 협업 툴에서 실시간 문서 동기화 (구글 Docs 같은 기능)
- HMR(Hot Module Replacement)도 사실 WebSocket으로 서버 ↔ 브라우저가 코드 변경 이벤트를 주고받음

# 트랜스파일러

### **트랜스파일러 (Transpiler)**

브라우저 엔진 자체를 건드리는 게 아니라, 엔진이 문제 없이 읽을 수 있는 **호환 코드**를 미리 만들어주는 거죠.

호환성을 위해 **트랜스파일링 + 폴리필**을 함께 사용하기도 함.

**"source-to-source compiler"**, 즉 **소스 코드를 다른 소스 코드로 변환하는 도구**예요.

같은 수준(레벨)의 프로그래밍 언어 사이에서 변환이 이루어진다는 게 특징.

(예: JavaScript → JavaScript, TypeScript → JavaScript)

[👉](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

즉, “한 언어에서 다른 언어로 바꿔주는 번역기”인데, 주로 실행 환경에 맞추기 위해 사용합니다.

### **대표적인 트랜스파일러**

[✅](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

**Babel** → 최신 JavaScript → 구버전 JavaScript

**TypeScript Compiler (tsc)** → TypeScript → JavaScript

**Sass/LESS** → CSS 전처리기 언어 → 표준 CSS

**CoffeeScript** → CoffeeScript → JavaScript

esbuild

| **구분** | **트랜스파일러** | **컴파일러** |
| --- | --- | --- |
| 변환 대상 | **소스 코드 → 소스 코드** | 소스 코드 → 기계어/바이트코드 |
| 수준(Level) | 같은 레벨 언어끼리 | 더 낮은 레벨 언어로 |
| 예시 | TS → JS, ES6 → ES5 | C → 기계어, Java → 바이트코드 |

### **트랜스파일러가 필요한 케이스**

[✅](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

### **1. 구형 브라우저 호환성 확보**

**문제**: Internet Explorer 같은 구형 브라우저는 최신 JS(ES6 이상) 문법을 지원하지 않음.

**해결**: Babel 같은 트랜스파일러로 ES6+ 코드를 ES5로 변환해서 구형 브라우저에서도 동작 가능하게 만듦.

### **2. TypeScript 사용 시**

**문제**: 브라우저는 TypeScript(.ts)를 직접 이해할 수 없음.

**해결**: tsc(TypeScript Compiler)로 TS를 JS로 트랜스파일해야 실행 가능.

[👉](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

개발자는 타입 안정성, 인터페이스, 제네릭 등을 활용할 수 있고, 런타임은 변환된 JS를 사용.

### **3. 실험적/미래 문법 사용**

**문제**: JavaScript의 새로운 기능(예: optional chaining ?., nullish coalescing ??)은 일부 환경에서 지원하지 않음.

**해결**: Babel이 아직 표준화되지 않은 문법까지 지원 → 현재 실행 가능한 문법으로 변환.

# **폴리필 (Polyfill)**

ex: core-js

**브라우저(또는 실행 환경)가 지원하지 않는 기능을 흉내 내서 구현한 코드**.

즉, **새로운 표준 기능**을 구형 환경에서도 쓸 수 있도록 “메우는 패치 코드”예요.

### **동작 원리**

[🔹](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

브라우저가 기능을 지원하는지 확인

지원하지 않으면 직접 구현한 코드 삽입

### **폴리필과 트랜스파일러 차이**

**트랜스파일러(Babel, SWC, TypeScript)**:

**문법 변환**을 담당. (예: ES6 → ES5)

하지만 **새 API**는 변환할 수 없음. (ex. Promise, fetch)

**폴리필**:

**기능(API) 자체를 구현**.

런타임에 동작.

[👉](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

둘은 자주

**함께 사용**

돼요.

Babel이 문법을 변환해주고,

core-js 같은 라이브러리가 폴리필을 추가해줌.

| **구분** | **트랜스파일러 (Transpiler)** | **폴리필 (Polyfill)** |
| --- | --- | --- |
| 목적 | 최신 **문법**을 구버전 문법으로 변환 | 최신 **API/기능**을 직접 구현 |
| 동작 시점 | 실행 전 (빌드 타임) | 실행 중 (런타임) |
| 예시 도구 | Babel, TypeScript | core-js, polyfill.io |
| 변환 대상 | let/const, 화살표 함수, 클래스, async/await 등 **문법** | Promise, fetch, Array.includes 등 **API** |
| 한계 | 문법만 변환, API 부족은 해결 불가 | 코드 크기 증가, 완벽히 동일하게 구현은 어려움 |

# 하이드레이션

**서버가 먼저 만든 HTML(SSR/SSG)** 위에, 브라우저가 **자바스크립트 로직과 이벤트를 “붙여서” 화면을 살아 움직이게 만드는 과정** 이야. 쉽게 말해: *HTML은 이미 그려져 있고* , 클라이언트는 거기에 **상태·이벤트 리스너**를 연결해서**앱을 작동 가능**하게 만든다.

# 서비스 워커

[Dependancy 관리](%EC%9B%B9%20%EA%B8%B0%ED%83%80/Dependancy%20%EA%B4%80%EB%A6%AC%2026acee38e89a80dbbaddef104f4068bf.md)

[ Vite](%EC%9B%B9%20%EA%B8%B0%ED%83%80/Vite%2026acee38e89a80e79721c8d96479cf86.md)

[Bundler ](%EC%9B%B9%20%EA%B8%B0%ED%83%80/Bundler%2026acee38e89a80fba0a5c6301337b874.md)

[상태관리 (Pinia, Redux)](%EC%9B%B9%20%EA%B8%B0%ED%83%80/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%20(Pinia,%20Redux)%2026acee38e89a8004a674d02eee96b0b7.md)

[MonoRepo ](%EC%9B%B9%20%EA%B8%B0%ED%83%80/MonoRepo%2028ccee38e89a80ffabe1c2ee9df88214.md)

[SEO ](%EC%9B%B9%20%EA%B8%B0%ED%83%80/SEO%2028ccee38e89a80038a2bd6719ea79f23.md)

[렌더링 방식 ](%EC%9B%B9%20%EA%B8%B0%ED%83%80/%EB%A0%8C%EB%8D%94%EB%A7%81%20%EB%B0%A9%EC%8B%9D%2028ccee38e89a807bb6cded7f10307aaf.md)

[라우터 ](%EC%9B%B9%20%EA%B8%B0%ED%83%80/%EB%9D%BC%EC%9A%B0%ED%84%B0%2028ccee38e89a80088e76d777f6e919b8.md)

[MSW(Mock service worker)](%EC%9B%B9%20%EA%B8%B0%ED%83%80/MSW(Mock%20service%20worker)%20299cee38e89a800c8793e923e01fe522.md)