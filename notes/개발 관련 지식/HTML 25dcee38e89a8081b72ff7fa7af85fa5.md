---
title: HTML
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# HTML

## HTML

### HTML 이란

HTML (**H**yper**t**ext **M**arkup **L**anguage)은 웹 페이지와 그 내용을 구조화하기 위해 사용하는 코드입니다. 예를 들면, 콘텐츠는 여러 개의 문단, 글 머리 목록이 구조화된 것이거나 사진이나 데이터 테이블일 수도 있습니다. 제목과 같이 이 글은 HTML과 그 기능에 대한 기본적인 이해를 제공할 것입니다.

즉, 일반 텍스트를 넘어서 다른 문서나 리소스로 연결되는 텍스트 

비선형적이고 연결된 구조를 가진 문서라고 보면됨 

문서의 구조와 의미를 표현하는 기호가 있음. 

구조를 기술하는 언어에 가까우며, 사람과 기계가 서로 이해할 수 있는 규칙있는 문법을 가진 언어임. 어떻게 동작할지는 정의하지 않는다. 

## **`doctype`은 어떤 기능을 하나요?**

- `doctpye` 선언은 `HTML` 문서가 어떤 버전으로 작성되었는지 브라우저에게 알려주는 역할을 합니다.
- 이렇게 선언하는 이유는 호환성을 높이기 위해서인데, `HTML`은 버전마다 적용되는 태그와 적용되지 않는 태그가 나뉜다.
- 구버전에서 신버전의 `HTML` 태그를 사용을 하게된다면, 웹 브라우저에서 문법오류로 간주하는데, 해당 선언을 통해 구버전과 신버전에 알맞게 문법 검사를 하는 역할을 수행하게 된다.

# 웹 표준

말 그대로**웹 기술이 일관되고 호환성 있게 동작하도록 정해진 국제적 규칙·규격**을 의미합니다. 즉, 어떤 브라우저(Chrome, Firefox, Safari, Edge)에서든

**동일한 방식으로 웹페이지가 보이고 동작하도록 만든 약속**이에요.

- **HTML (구조)**
    - 문서의 의미론적 구조 정의 (`<header>`, `<section>`, `<footer>` 등).
- **CSS (표현)**
    - 색상, 레이아웃, 애니메이션 같은 시각적 표현 정의.
- **JavaScript / ECMAScript (동작)**
    - 동적인 상호작용 로직 표준화.
- **DOM (Document Object Model)**
    - 브라우저가 HTML을 객체 트리로 표현하는 방식.
- **웹 API**
    - `fetch`, `WebSocket`, `localStorage`, `Canvas` 같은 기능들.

## 태그 관련 정리

### 시맨틱 태그(Sementic tag) 란 무엇이며, 왜 중요한가요?

- 포함된 콘텐츠의 특정 의미를 정의하고, 목적을 갖는 태그이다.
- Block Element로 취급
- <header>, <nav>, <article>, <section>, <footer>, <main> 이 존재.
- 태그에 의미를 부여함으로써 웹사이트의 구조를 쉽게 파악하기 위해 존재
- 가독성 향상, 표준 준수, SEO 최적화, 접근성 향상 (Accessibility) 에 도움이 됨
- IE8이하는 그냥 인라인요소로 취급해 깨질 수 있음

### <Article>

독립적으로 존재할 수 있는 콘텐츠 단위를 의미

다른 곳에 가져다 놔도 의미가 통하는 콘텐츠에 적합함 

하나의 완결된 콘텐츠 덩어리 일 때 <article>을 쓰며, 예시로 사용자 리뷰 정도가 있음 

### <Section>

문서를 주제별로 구획하는 용도 

<h1 ~ h6> 가 존재하며, 논리적으로 문서를 나누는데 사용함 

### <Main>

페이지의 주된 콘텐츠 (main content)를 감싸는 영역 

문서에서 한 번만 사용해야함 

### <Form>

기본적으로 Block-level 요소 

HTML `form` 태그는 사용자로부터 데이터를 입력받을 수 있는 입력 양식을 만들 때 사용합니다.

- `action` 속성: 폼 데이터를 전송할 URL을 지정합니다. (`/submit` 예시)
→ 직접 JS 호출 불가
- `method` 속성: 폼 데이터를 전송할 HTTP 메소드를 지정합니다. (`post` 또는 `get`)
- **`<label>` 태그:** 폼 요소의 레이블을 지정합니다. `for` 속성은 해당 레이블이 어떤 입력 요소를 위한 것인지 연결합니다.
- **`<input>` 태그:** 다양한 종류의 입력 요소를 만듭니다.
    - `type` 속성: 입력 요소의 형식을 지정합니다. (`text`, `email`, `submit` 등)
    - `id` 속성: 폼 요소의 고유한 ID를 지정합니다.
    - `name` 속성: 폼 요소의 이름을 지정합니다. 이 이름은 서버에서 폼 데이터를 받을 때 사용합니다.
- **`<textarea>` 태그:** 여러 줄의 텍스트를 입력할 수 있는 영역을 만듭니다.
    - `id` 속성과 `name` 속성은 `<input>` 태그와 같습니다.
- **`<br>` 태그:** 줄바꿈을 추가합니다.

`<form>`은 HTML 명세에 의해 브라우저가 기본 동작을 자동으로 붙여줍니다. 주요 이벤트는 다음과 같아요.

 (1) `submit` 이벤트

`form`의 `submit` 이벤트는 **사용자가 폼을 제출할 때 발생**하며, `<input type="submit">`, `<input type="image">`를 클릭하거나 인풋 필드에서 Enter 키를 눌러 폼을 전송하는 경우에 발생합니다. 이 이벤트는 폼 데이터 유효성 검사, 서버로의 데이터 전송 전처리 또는 전송 후처리 등 폼 제출 과정 전반을 제어하는 데 사용되며, 이벤트 핸들러에서 `event.preventDefault()`를 호출하여 브라우저의 기본 폼 제출 동작(페이지 새로고침)을 막고, 사용자 정의 로직을 수행할 수 있습니다. 

 (2) `reset` 이벤트

폼(form)의 `reset` 이벤트는 `reset` 유형의 `<input>` 요소를 클릭하여 폼의 입력 값들을 초기화할 때 발생하며, 이벤트를 처리하기 위해 HTML `onreset` 속성을 사용하거나 JavaScript의 `addEventListener`를 사용하여 `reset` 이벤트를 등록할 수 있습니다. 폼을 초기화하는 `reset()` 메서드를 직접 호출할 수도 있습니다. 

 (3) `formdata` 이벤트 (HTML5 이후)

 (4) 내부 요소와의 상호작용

- `<input>`, `<select>`, `<textarea>` 같은 자식 요소들이 자동으로 `form.elements` 컬렉션에 등록됨.
- `form.name` 이나 `form.id` 로도 직접 접근 가능.

시맨틱 마크업을 제대로 하지 않았을 때 발생할 수 있는 문제

시맨틱 마크업을 제대로 하지 않으면 접근성 저하, SEO 불이익, 유지보수 어려움, 표준성 저하 같은 문제가 발생할 수 있습니다.

### 1. 접근성 문제 (Accessibility)

- 시각 장애인이 스크린 리더를 사용할 때 문서 구조를 제대로 이해하지 못함.
- 예: 제목을 `<div>`로만 표시하면 스크린 리더가 “이건 제목”이라고 인식하지 못해 내비게이션 불편.

### 🔸 2. SEO(검색 엔진 최적화) 문제

- 검색 엔진 크롤러가 콘텐츠 의미를 정확히 파악하지 못해 검색 랭킹이 떨어질 수 있음.
- 예: `<article>` 없이 `<div>`만 쓰면, 구글이 “이게 독립적인 글”인지 인식하기 어렵다.

### 🔸 3. 유지보수/협업 문제

- 코드를 읽는 사람(개발자)이 구조를 이해하기 어려워짐.
- `<header>` / `<nav>` / `<footer>` 대신 `<div>`만 있으면 역할 구분이 힘듦.

### 🔸 4. 표준성/호환성 문제

- 웹 표준을 따르지 않으면 브라우저별/환경별로 다르게 동작할 가능성이 높아짐.
- 향후 기술(검색엔진/AI/보조기기)과 호환성 떨어짐.

## 만약 form에서 호출해야하는 API를 서비스의 프록시 객체로 관리하고 있다면, 어떻게 사용해야 하는지?

**`submit` 이벤트를 JS에서 가로채서 → 직접 API(Service) 함수 호출** 하는 패턴을 씁니다.

### <form> 태그에서 method="GET"과 method="POST"의 차이를 설명해보세요

Form에서 `GET`은 조회용으로, 예를 들어 검색창, 필터링, 페이지네이션처럼 URL에 결과를 노출해 공유하거나 북마크할 필요가 있을 때 사용합니다. 반대로 데이터 변경이나 민감한 정보 전송에는 `POST`를 씁니다.

`GET`은 데이터를 URL 쿼리스트링으로 전송하고 캐싱이나 북마크가 가능하지만 보안에 취약하고 데이터 길이에 제한이 있습니다. 반대로 `POST`는 데이터를 요청 본문에 담아 전송해 보안상 더 안전하고 용량 제한이 없지만 캐싱되지 않고 새로고침 시 재전송 경고가 나타납니다. 그래서 조회는 GET, 등록/수정/삭제 같은 변경 작업은 POST를 주로 사용합니다.

get은 form을 통해 검색할 때, 필터링, 정렬, 페이지네이션 할 때 (서버 상태 안바꿀때)

### 블록 레벨 요소 (Block-level element)

기본적으로 한 줄 전체 차지 + 줄 바꿈 발생 

→ 이런 현상이 나타나는 이유는 브라우저 기본 렌더링 규칙의 속상값 때문 (display: block) 
예시 태그: <div>, <p>, <section> <ul>, <ol>, <li>, <table>

### 인라인 요소 (Inline elements)

텍스트 흐름속에 녹아듦, 줄바꿈 없음 

<span>, <a>, <strong>, <em>, <img>

### 인라인 블록 요소 (Inline-block elements)

인라인처럼 한 줄에 배치되지만, 블록처럼 width/height, padding, margin 제어 가능 

<button>, <input>, <select>, <textarea>

### <img> 태그에서 alt 속성은 왜 중요한가요? (접근성과 SEO 관점 포함)

`alt` 속성은 이미지의 대체 텍스트로, 시각장애인 보조기기에서 내용을 전달하는 데 꼭 필요합니다. 또 검색엔진은 이미지를 직접 인식하지 못하기 때문에, alt를 통해 의미를 파악하고 검색 결과에 반영합니다. 따라서 접근성과 SEO 양쪽 모두에서 중요한 속성입니다

### 웹 표준과 크로스 브라우징을 위해 HTML에서 주의해야 할 점은 무엇인가요?

웹 표준 + 크로스 브라우징”을 안정적으로 맞추려면, **표준 문법을 지키고(Valid), 의미를 명확히 하고(Semantic), 기능은 점진적으로 확장(PE/PWA)** 하는 게 핵심입니다. HTML 관점에서 꼭 지켜야 할 체크리스트를 압축해서 드릴게요.
****

- HTML5 입력 타입 사용하되 **폴백 고려**:
    - `type="date"`, `type="email"` 등은 브라우저별 UI 다름 → **서버/JS 재검증 필수**.
- `<script defer>` 기본, **순서 보장 + DOM 준비 후 실행**.
- 외부 독립 스크립트(분석/광고)는 `async` 검토.

브라우저 동작 

## DOM 이란

DOM은 HTML 문서를 객체 기반 트리 구조로 표현한 모델로, JavaScript가 이를 조작해 동적인 웹 페이지를 만들 수 있게 해줍니다.

**DOM(Document Object Model)** 은

👉 “브라우저가 HTML, XML 문서를 객체(트리 구조)로 표현한 프로그래밍 인터페이스” 입니다.

- **Document** → 문서 (HTML, XML)
- **Object** → 문서의 각 요소를 객체로 표현
- **Model** → 문서 전체를 트리(Tree) 구조로 추상화

즉, 우리가 작성한 **HTML 태그들을 브라우저가 이해할 수 있도록 객체로 변환**한 구조가 DOM이에요.

## 📌 DOM 생성 & 조작 과정

**DOM은 HTML 문서를 트리 구조로 표현한 객체 모델입니다. 브라우저는 HTML을 파싱해 DOM Tree를 만들고, CSS와 결합해 Render Tree를 생성합니다. 이후 JavaScript로 DOM을 조작해 동적인 웹 페이지를 구현할 수 있습니다.**

### 1. HTML 파싱 (Parsing)

브라우저는 HTML 문서를 위에서 아래로 읽으면서 **DOM 트리(DOM Tree)** 를 만듭니다.

### 2. DOM 트리 (DOM Tree)

- `Document` 객체가 최상위(root)
- 각 태그(`<html>`, `<body>`, `<h1>` …)가 노드(node)로 표현됨
- 텍스트도 `"Hello"` 처럼 별도의 **텍스트 노드**로 존재

### 3. CSSOM과 결합 → Render Tree

- HTML에서 DOM Tree
- CSS에서 CSSOM Tree
- 두 개가 합쳐져 **Render Tree** 가 만들어짐 → 브라우저가 이걸 기반으로 화면을 그림(Paint)

## 4. JavaScript로 DOM 조작

DOM API를 통해 페이지 내용을 동적으로 바꿀 수 있습니다.

## **📌 CSSOM 생성 과정**

“CSSOM은 브라우저가 CSS를 토큰화 → 파싱 → 규칙 집합 생성 과정을 거쳐 트리 구조로 만든 것입니다. 이후 DOM과 결합해 Render Tree를 구성하고, 여기서 최종 스타일을 계산해 화면에 그립니다.”

### 1. CSS 리소스 로드 (Loading)

- HTML 파싱 중 `<link rel="stylesheet">`, `<style>`, `@import` 같은 **CSS 참조**를 만나면 브라우저는 CSS 파일을 가져옵니다.
- 외부 CSS는 네트워크 요청이 필요해서 **렌더링을 차단(blocking)** 하는 경우가 많습니다.

### 2. 토큰화 (Tokenization)

- 불러온 CSS 텍스트를 **토큰(token)** 으로 쪼갭니다.

### 3. 파싱 (Parsing)

- 토큰을 **노드(node)** 로 바꿔 **규칙(규칙 집합, Rule Set)** 을 만듭니다.

### 4. CSSOM 트리 생성 (Building the CSSOM Tree)

- 선택자와 선언들을 모아 **트리 구조로 저장**합니다.
- DOM처럼 부모-자식 관계는 아니지만, **스타일 상속/우선순위 계산**을 위해 계층적 구조를 가짐.

### 5. 스타일 계산 (Style Calculation)

- DOM과 CSSOM을 결합해서 각 요소에 **최종 스타일(Computed Style)** 을 계산합니다.
- 이때 **상속, 캐스케이딩(Cascading), 우선순위(Specificity)** 가 적용됩니다.
- 예: `p` 태그 → `font-size: 14px` (자신의 규칙) + `color: black` (body로부터 상속)

## Google.com을 입력했을 때 일어나는 일

# 1) 주소창에서의 해석/결정

1. 사용자가 `google.com` 입력
2. 브라우저가 **탐색 vs 검색**을 판별(히스토리/오토컴플릿/검색엔진 규칙).
3. 스킴이 없으므로 **HTTPS 시도**(대부분의 브라우저는 HTTPS 우선, HSTS 프리로드 도메인은 강제 업그레이드).
    
    → 최종 타깃: `https://google.com/` (필요 시 `www.` 리다이렉트 가능)
    

# 2) 네트워크 연결 준비

1. **DNS 조회**: 캐시(브라우저/OS/라우터/리졸버) → 없으면 재귀 조회로 `A/AAAA` 레코드 획득.
2. **연결 수립**
    - **HTTP/3 가능**: UDP 기반 **QUIC 핸드셰이크**(ALPN으로 `h3` 협상).
    - 아니면 **TCP 3-way** → **TLS 1.3 핸드셰이크**(SNI, ALPN으로 `h2`/`http/1.1` 결정).
    - 서버 인증서 검증(체인/만료/호스트명/OCSP 스테이플링, HSTS 위반 차단).

# 3) 요청 전 단계(브라우저 측)

1. **서비스 워커**: 해당 오리진에 등록되어 있고 범위가 매치되면 **네비게이션 요청을 가로채** 캐시/프리로드를 응답할 수 있음(첫 방문이면 보통 없음).
2. **HTTP 캐시**: 동일 URL이 캐시돼 있고 유효하면 바로 사용, 아니면 조건부 요청(ETag/Last-Modified).

# 4) 요청 전송

1. 예시: `GET / HTTP/2`
    - 주요 헤더: `Host`, `User-Agent`, `Accept*`, `Accept-Language`, `Cookie(있다면; SameSite/Secure 규칙)`, `Referer-Policy`에 따른 `Referer`.
    - 전송 최적화: HPACK/QPACK 압축, TCP/TLS 레벨에서는 TLS 레코드/패킷화.

# 5) 서버 측 처리(간략)

1. Anycast/CDN/LB를 거쳐 **가까운 엣지**로 라우팅 → 백엔드 선택.
2. 인증/리다이렉트/AB 테스트 결정 → HTML(또는 리다이렉트 301/302) 응답 생성.
    - 압축(`br`/`gzip`), 캐시 지시자(`Cache-Control`, `ETag`), 보안 헤더(CSP/HSTS/COOP/ CORP) 포함.

# 6) 응답 수신 & 리다이렉트

1. 브라우저가 **상태코드** 해석:
    - 200: 본문 처리
    - 301/302: 대상 URL로 재탐색(예: `https://www.google.com/` 지역도메인 등)
    - 304: 캐시 재사용

# 7) 렌더링 파이프라인(크리티컬 렌더링 패스)

1. **HTML 파싱 → DOM 생성**(프리로드 스캐너가 CSS/JS/프리커넥트 링크를 선요청).
2. **CSS 파싱 → CSSOM** (CSS는 렌더 차단)
3. **Render Tree = DOM + CSSOM** → **Layout(레이아웃)** → **Paint(페인트)** → **Composite(합성/GPU)**
4. **JS 실행**:
    - `<script>`는 기본 차단, `defer/async`로 비차단화 가능.
    - JS가 DOM/CSSOM에 접근하며 추가 네트워크 요청(Fetch/XHR, 모듈/다이내믹 임포트).
5. **폰트/이미지**: `font-display` 정책 따라 FOUT/FOIT, 이미지 디코딩/디퍼/레이징.
6. **보안/정책 적용**: SOP, CORS, Mixed Content 차단, CSP 위반 차단.

## 그냥 HTML에서 렌더링 하는거랑 어떤 과정에서 차이가 있어?

일반 HTML 렌더링은 브라우저가 문서를 그대로 파싱해 바로 화면을 그리지만, Vue 같은 SPA는 초기 HTML은 비어 있고 JS가 실행되어 Virtual DOM을 기반으로 DOM을 구성해야 화면이 나타납니다. 대신 한 번 로드되면 페이지 전환 시 서버 요청 없이 Virtual DOM만 갱신하므로 빠르고 동적인 UX를 제공합니다.

## ✅ 1. 일반 HTML 렌더링 (전통적 MPA, Multi Page Application)

1. 브라우저가 HTML 문서를 다운로드
2. HTML 파싱 → DOM 생성
3. CSS 파싱 → CSSOM 생성
4. JS 실행 (필요시 DOM 조작)
5. 바로 **렌더 트리(Render Tree) → Layout → Paint → 화면 표시**

👉 HTML 자체가 완성된 문서라서 **브라우저는 바로 그리기(Paint)** 할 수 있음.

👉 각 페이지 이동마다 서버에서 **새로운 HTML 문서**를 받아와 렌더링.

👉 JS는 “보조 역할”(동적 인터랙션, 검증 등)로 사용됨.

## ✅ 2. Vue 같은 SPA 렌더링

1. 브라우저가 `index.html`을 다운로드 → 보통 내용은 `<div id="app"></div>` 같은 최소 구조
2. JS 번들(Vue runtime + 앱 코드)을 다운로드 후 실행
3. Vue가 Virtual DOM 기반으로 **DOM 트리를 생성/마운트** → 실제 DOM에 반영
4. 이후 데이터 변경 시 → Virtual DOM diff → 실제 DOM에 최소 변경 반영

👉 HTML만으로는 초기 UI가 보이지 않고, **JS 실행이 끝나야 화면이 뜸** (CSR의 단점)

👉 페이지 이동 시 새 HTML 요청이 아닌, **라우터(Vue Router)와 Virtual DOM 갱신**으로 처리 → 새로고침 없이 부드러운 전환

👉 JS가 “메인 렌더링 엔진” 역할

## **쿠키, sessionStorage, localStorage의 차이점은 무엇인가요?**

쿠키, sessionStorage, localStorage는 모두 웹 브라우저에서 사용되는 데이터 저장방식입니다. 이 세가지의 주요한 차이점은 저장 용량, 데이터 유지기간, 그리고 데이터 접근성에 있습니다.

**쿠키**

- 쿠키는 서버와 클라이언트 간 상태 정보를 유지하거나 사용자의 이전 상태를 기억하기 위해 사용됩니다.
- 쿠키는 최대 4Kb의 데이터만을 저장할 수 있으며, 만료 날짜가 지나면 자동으로 삭제됩니다.
- 쿠키는 HTTP 헤더를 통해 서버와 클라이언트 간에 주고받을 수 있습니다.

**2. sessionStorage**

- 세션스토리지는 브라우저의 세션 동안만 데이터를 저장하게 됩니다.
    - 즉, 브라우저가 닫히면 데이터는 사라집니다.
- 저장용량은 브라우저마다 다르지만 일반적으로 5MB이상입니다.
- 세션 스토리지는 오직 자바스크립트를 통해서만 접근할 수 있습니다.

**3. localStorage**

- 로컬스토리지는 브라우저가 닫혀도 데이터가 유지되게 됩니다.
- 저장용량은 브라우저에 따라 다르지만 일반적으로 5MB ~ 10MB입니다.
- 로컬스토리지 또한 자바스크립트를 통해서만 접근할 수 있습니다.

**이처럼 세가지모두 장단점이 존재하며, 사용목적에 따라 적절히선택해야합니다.**

- 쿠키는 서버와 상호작용이 필요하거나 여러 도메인에서 정보를 공유해야하는 경우 사용합니다.(자동로그인 등)
- 세션스토리지는 임시데이터를 저장하거나 브라우저 세션동안 유지될 필요가 있는 정보를 저장하는 경우 사용합니다.(채팅 메시지, 실시간 업데이트 정보 등)
- 로컬스토리지는 클라이언트에 영구적으로 저장해야하는 정보를 저장하는 경우에 사용됩니다.(사용자 테마등)

## W3C

W3C(World Wide Web Consortium)”는 웹 표준을 만드는 기구

## 기본 `<script>` vs `type="module"`

```html
<!-- 일반 스크립트 -->
<script src="app.js"></script>

<!-- 모듈 스크립트 -->
<script type="module" src="app.js"></script>

```

- **일반 스크립트**
    - 전역 스코프(`window`)에 모든 변수/함수가 올라감
    - `import`, `export` 같은 모듈 문법 사용 불가
- **모듈 스크립트**
    - 파일이 독립된 스코프(모듈 스코프)로 실행 → 전역 오염 X
    - `import`, `export` 사용 가능
    - 자동으로 `strict mode` 적용됨

| 구분 | `<script defer>` | `<script type="module">` |
| --- | --- | --- |
| **의미** | 일반 스크립트를 **지연 실행** | 스크립트를 **ES 모듈로 실행** |
| **실행 시점** | DOM 파싱 완료 후 실행 | DOM 파싱 완료 후 실행 (기본적으로 defer 동작 내장) |
| **스코프** | 전역 스코프 → `window` 오염 | **모듈 스코프** (파일마다 독립), 전역 오염 없음 |
| **`import/export` 지원** | ❌ 불가능 | ✅ 가능 |
| **엄격 모드 (strict mode)** | 선택적 (`"use strict"`) | ✅ 항상 적용 |
| **경로 표기** | `src="app.js"` 가능 | `src="./app.js"`처럼 **상대/절대 경로 필수** |
| **중복 실행 방지** | 동일 스크립트 여러 번 불러오면 실행됨 | 같은 모듈 여러 번 import해도 **한 번만 실행** (캐싱) |
| **CORS 규칙** | 단순히 src만 있으면 됨 | 다른 도메인 import 시 CORS 헤더 필요 |
| **호환성** | 오래된 브라우저에서도 지원 | ES6+ 지원 브라우저만 (현대 브라우저 대부분 지원) |

[쿠키, 세션스토리지, 로컬스토리지](HTML/%EC%BF%A0%ED%82%A4,%20%EC%84%B8%EC%85%98%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80,%20%EB%A1%9C%EC%BB%AC%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%20268cee38e89a806696fadc18093c513d.md)

[렌더링 최적화 ](HTML/%EB%A0%8C%EB%8D%94%EB%A7%81%20%EC%B5%9C%EC%A0%81%ED%99%94%20269cee38e89a80c3afe9e5fe81483504.md)

[iframe](HTML/iframe%2026bcee38e89a8074a4b8e5bf79145873.md)

[HTML과 브라우저 렌더링 ](HTML/HTML%EA%B3%BC%20%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%A0%8C%EB%8D%94%EB%A7%81%20257cee38e89a80658e63c98ec07f6534.md)

[데이터 전송 ](HTML/%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%A0%84%EC%86%A1%202becee38e89a803bb0fae10c5c46e202.md)