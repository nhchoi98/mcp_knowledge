---
title: HTML과 브라우저 렌더링
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# HTML과 브라우저 렌더링

## HTML

### HTML 이란

HTML (**H**yper**t**ext **M**arkup **L**anguage)은 웹 페이지와 그 내용을 구조화하기 위해 사용하는 코드입니다. 예를 들면, 콘텐츠는 여러 개의 문단, 글 머리 목록이 구조화된 것이거나 사진이나 데이터 테이블일 수도 있습니다. 제목과 같이 이 글은 HTML과 그 기능에 대한 기본적인 이해를 제공할 것입니다.

즉, 일반 텍스트를 넘어서 다른 문서나 리소스로 연결되는 텍스트 

비선형적이고 연결된 구조를 가진 문서라고 보면됨 

문서의 구조와 의미를 표현하는 기호가 있음. 

구조를 기술하는 언어에 가까우며, 사람과 기계가 서로 이해할 수 있는 규칙있는 문법을 가진 언어임. 어떻게 동작할지는 정의하지 않는다. 

## **`doctype`은 어떤 기능을 하나요?**

- `doctpye` 선언은 `HTML` 문서가 어떤 버전으로 작성되었는지 브라우저에게 알려주는 역할을 합니다.
- 이렇게 선언하는 이유는 호환성을 높이기 위해서인데, `HTML`은 버전마다 적용되는 태그와 적용되지 않는 태그가 나뉜다.
- 구버전에서 신버전의 `HTML` 태그를 사용을 하게된다면, 웹 브라우저에서 문법오류로 간주하는데, 해당 선언을 통해 구버전과 신버전에 알맞게 문법 검사를 하는 역할을 수행하게 된다.

## 태그 관련 정리

### 시맨틱 태그(Sementic tag) 란 무엇이며, 왜 중요한가요?

- 포함된 콘텐츠의 특정 의미를 정의하고, 목적을 갖는 태그이다.
- Block Element로 취급
- <header>, <nav>, <article>, <section>, <footer>, <main> 이 존재.
- 태그에 의미를 부여함으로써 웹사이트의 구조를 쉽게 파악하기 위해 존재
- 가독성 향상, 표준 준수, SEO 최적화, 접근성 향상 (Accessibility) 에 도움이 됨
- IE8이하는 그냥 인라인요소로 취급해 깨질 수 있음

### <Article>

독립적으로 존재할 수 있는 콘텐츠 단위를 의미

다른 곳에 가져다 놔도 의미가 통하는 콘텐츠에 적합함 

하나의 완결된 콘텐츠 덩어리 일 때 <article>을 쓰며, 예시로 사용자 리뷰 정도가 있음 

### <Section>

문서를 주제별로 구획하는 용도 

<h1 ~ h6> 가 존재하며, 논리적으로 문서를 나누는데 사용함 

### <Main>

페이지의 주된 콘텐츠 (main content)를 감싸는 영역 

문서에서 한 번만 사용해야함 

### <Form>

기본적으로 Block-level 요소 

HTML `form` 태그는 사용자로부터 데이터를 입력받을 수 있는 입력 양식을 만들 때 사용합니다.

- `action` 속성: 폼 데이터를 전송할 URL을 지정합니다. (`/submit` 예시)
→ 직접 JS 호출 불가
- `method` 속성: 폼 데이터를 전송할 HTTP 메소드를 지정합니다. (`post` 또는 `get`)
- **`<label>` 태그:** 폼 요소의 레이블을 지정합니다. `for` 속성은 해당 레이블이 어떤 입력 요소를 위한 것인지 연결합니다.
- **`<input>` 태그:** 다양한 종류의 입력 요소를 만듭니다.
    - `type` 속성: 입력 요소의 형식을 지정합니다. (`text`, `email`, `submit` 등)
    - `id` 속성: 폼 요소의 고유한 ID를 지정합니다.
    - `name` 속성: 폼 요소의 이름을 지정합니다. 이 이름은 서버에서 폼 데이터를 받을 때 사용합니다.
- **`<textarea>` 태그:** 여러 줄의 텍스트를 입력할 수 있는 영역을 만듭니다.
    - `id` 속성과 `name` 속성은 `<input>` 태그와 같습니다.
- **`<br>` 태그:** 줄바꿈을 추가합니다.

`<form>`은 HTML 명세에 의해 브라우저가 기본 동작을 자동으로 붙여줍니다. 주요 이벤트는 다음과 같아요.

 (1) `submit` 이벤트

`form`의 `submit` 이벤트는 **사용자가 폼을 제출할 때 발생**하며, `<input type="submit">`, `<input type="image">`를 클릭하거나 인풋 필드에서 Enter 키를 눌러 폼을 전송하는 경우에 발생합니다. 이 이벤트는 폼 데이터 유효성 검사, 서버로의 데이터 전송 전처리 또는 전송 후처리 등 폼 제출 과정 전반을 제어하는 데 사용되며, 이벤트 핸들러에서 `event.preventDefault()`를 호출하여 브라우저의 기본 폼 제출 동작(페이지 새로고침)을 막고, 사용자 정의 로직을 수행할 수 있습니다. 

 (2) `reset` 이벤트

폼(form)의 `reset` 이벤트는 `reset` 유형의 `<input>` 요소를 클릭하여 폼의 입력 값들을 초기화할 때 발생하며, 이벤트를 처리하기 위해 HTML `onreset` 속성을 사용하거나 JavaScript의 `addEventListener`를 사용하여 `reset` 이벤트를 등록할 수 있습니다. 폼을 초기화하는 `reset()` 메서드를 직접 호출할 수도 있습니다. 

 (3) `formdata` 이벤트 (HTML5 이후)

 (4) 내부 요소와의 상호작용

- `<input>`, `<select>`, `<textarea>` 같은 자식 요소들이 자동으로 `form.elements` 컬렉션에 등록됨.
- `form.name` 이나 `form.id` 로도 직접 접근 가능.

(5) 

## 만약 form에서 호출해야하는 API를 서비스의 프록시 객체로 관리하고 있다면, 어떻게 사용해야 하는지?

**`submit` 이벤트를 JS에서 가로채서 → 직접 API(Service) 함수 호출** 하는 패턴을 씁니다.

### <form> 태그에서 method="GET"과 method="POST"의 차이를 설명해보세요

Form에서 `GET`은 조회용으로, 예를 들어 검색창, 필터링, 페이지네이션처럼 URL에 결과를 노출해 공유하거나 북마크할 필요가 있을 때 사용합니다. 반대로 데이터 변경이나 민감한 정보 전송에는 `POST`를 씁니다.

`GET`은 데이터를 URL 쿼리스트링으로 전송하고 캐싱이나 북마크가 가능하지만 보안에 취약하고 데이터 길이에 제한이 있습니다. 반대로 `POST`는 데이터를 요청 본문에 담아 전송해 보안상 더 안전하고 용량 제한이 없지만 캐싱되지 않고 새로고침 시 재전송 경고가 나타납니다. 그래서 조회는 GET, 등록/수정/삭제 같은 변경 작업은 POST를 주로 사용합니다.

get은 form을 통해 검색할 때, 필터링, 정렬, 페이지네이션 할 때 (서버 상태 안바꿀때)

### 블록 레벨 요소 (Block-level element)

기본적으로 한 줄 전체 차지 + 줄 바꿈 발생 

→ 이런 현상이 나타나는 이유는 브라우저 기본 렌더링 규칙의 속상값 때문 (display: block) 
예시 태그: <div>, <p>, <section> <ul>, <ol>, <li>, <table>

### 인라인 요소 (Inline elements)

텍스트 흐름속에 녹아듦, 줄바꿈 없음 

<span>, <a>, <strong>, <em>, <img>

### 인라인 블록 요소 (Inline-block elements)

인라인처럼 한 줄에 배치되지만, 블록처럼 width/height, padding, margin 제어 가능 

<button>, <input>, <select>, <textarea>

### <img> 태그에서 alt 속성은 왜 중요한가요? (접근성과 SEO 관점 포함)

`alt` 속성은 이미지의 대체 텍스트로, 시각장애인 보조기기에서 내용을 전달하는 데 꼭 필요합니다. 또 검색엔진은 이미지를 직접 인식하지 못하기 때문에, alt를 통해 의미를 파악하고 검색 결과에 반영합니다. 따라서 접근성과 SEO 양쪽 모두에서 중요한 속성입니다

### 웹 표준과 크로스 브라우징을 위해 HTML에서 주의해야 할 점은 무엇인가요?

웹 표준 + 크로스 브라우징”을 안정적으로 맞추려면, **표준 문법을 지키고(Valid), 의미를 명확히 하고(Semantic), 기능은 점진적으로 확장(PE/PWA)** 하는 게 핵심입니다. HTML 관점에서 꼭 지켜야 할 체크리스트를 압축해서 드릴게요.
****

- HTML5 입력 타입 사용하되 **폴백 고려**:
    - `type="date"`, `type="email"` 등은 브라우저별 UI 다름 → **서버/JS 재검증 필수**.
- `<script defer>` 기본, **순서 보장 + DOM 준비 후 실행**.
- 외부 독립 스크립트(분석/광고)는 `async` 검토.

## Shadow DOM과 일반 DOM의 차이는 무엇인가요?

| 구분 | 일반 DOM (Light DOM) | Shadow DOM |
| --- | --- | --- |
| **범위** | 문서 전역 | 특정 요소 내부에만 존재 |
| **스타일 적용** | 전역 CSS 영향 받음 | 로컬 CSS만 적용 (외부와 격리) |
| **캡슐화** | 없음 | 있음 (DOM, 스타일 모두) |
| **접근성** | `document.querySelector`로 접근 가능 | `shadowRoot`를 통해서만 접근 |
| **사용 목적** | 전체 문서 구조 표현 | 재사용 가능한 컴포넌트 구현 (Web Components) |

일반 DOM은 문서 전역의 트리로 스타일 충돌이 발생할 수 있지만, Shadow DOM은 특정 요소 내부에 캡슐화된 DOM과 스타일을 제공해 외부와 격리됩니다. 이를 통해 Web Components가 독립적으로 동작할 수 있습니다

## Script 태그의 위치별 넣는거 질문

## <script> 태그를 head와 body에 각각 넣을 때 차이가 있을까요?

“`<script>`를 `<head>`에 넣으면 HTML 파싱을 멈추고 실행하기 때문에 렌더링 차단이 발생합니다. 그래서 보통은 `defer`나 `async` 속성을 붙이거나 `<body>` 끝에 넣어 DOM이 다 만들어진 뒤 실행되도록 합니다. 최근에는 성능 최적화 때문에 `<head defer>` 방식이 가장 권장됩니다.”

### ✅ 1. `<head>` 안에 넣을 때

- 브라우저는 HTML을 위에서부터 **순차적으로 파싱**합니다.
- `<head>` 안의 `<script>`를 만나면:
    - 스크립트 파일을 **다운로드하고 실행**할 때까지 **HTML 파싱이 멈춥니다** → **렌더링 차단(Render-blocking)** 발생.
- 이 때문에 화면 표시가 지연될 수 있어요.

👉 그래서 `<head>`에 넣을 때는 보통 다음 속성을 같이 사용합니다:

- `defer` : HTML 파싱을 멈추지 않고, **DOM이 완전히 만들어진 뒤 실행**
- `async` : HTML 파싱을 멈추고 다운로드가 끝나는 즉시 실행 (여러 스크립트가 있을 때 순서 보장 X)

### ✅ 2. `<body>` 끝에 넣을 때

- 전통적으로 가장 많이 쓰던 방식.
- HTML 본문이 다 파싱된 뒤에 JS를 불러오므로, **DOM이 이미 준비된 상태에서 실행** 가능.
- 별도의 `defer` 속성이 없어도 DOM 조작에 안전합니다.
- 렌더링 차단이 거의 없어서 사용자에게 빠르게 화면을 보여줄 수 있음.

### 차이정리

| 위치 | 특징 | 문제점/장점 |
| --- | --- | --- |
| `<head>` | DOM 생성 전에 실행됨 | 렌더링 차단 발생 → 화면 늦게 뜰 수 있음 |
| `<head defer>` | DOM 파싱 완료 후 실행 | 렌더링 차단 없음, 순서 보장 |
| `<head async>` | 다운로드 끝나는 즉시 실행 | 렌더링 차단 없음, 순서 보장 X |
| `<body>` 끝 | DOM 생성 후 실행 | 전통적 방식, 안전하지만 JS 다운로드가 늦게 시작됨 |

## `defer` vs `async` 차이

둘 다 `<script>` 태그의 **렌더링 차단 문제**를 해결하기 위한 속성이지만, **실행 시점과 순서**가 다릅니다.

### 📌 `defer`

- **다운로드**: HTML 파싱과 병렬로 JS 파일 다운로드
- **실행 시점**: **DOM 파싱이 끝난 직후** (DOMContentLoaded 이벤트 전에 실행)
- **순서 보장**: 여러 개 있으면 **작성된 순서대로 실행됨**

### 📌 `async`

- **다운로드**: HTML 파싱과 병렬로 JS 파일 다운로드
- **실행 시점**: 다운로드가 끝나는 즉시 실행 (HTML 파싱이 잠시 멈춤)
- **순서 보장**: 없음 (파일 크기, 네트워크 속도 따라 먼저 내려받은 스크립트가 먼저 실행)

👉 정리

- **순서 보장이 필요하면 → defer**
- **독립적인 스크립트(광고, 통계 코드 등) → async**

## 시맨틱 마크업을 제대로 하지 않았을 때 발생할 수 있는 문제

시맨틱 마크업을 제대로 하지 않으면 접근성 저하, SEO 불이익, 유지보수 어려움, 표준성 저하 같은 문제가 발생할 수 있습니다.

### 1. 접근성 문제 (Accessibility)

- 시각 장애인이 스크린 리더를 사용할 때 문서 구조를 제대로 이해하지 못함.
- 예: 제목을 `<div>`로만 표시하면 스크린 리더가 “이건 제목”이라고 인식하지 못해 내비게이션 불편.

### 🔸 2. SEO(검색 엔진 최적화) 문제

- 검색 엔진 크롤러가 콘텐츠 의미를 정확히 파악하지 못해 검색 랭킹이 떨어질 수 있음.
- 예: `<article>` 없이 `<div>`만 쓰면, 구글이 “이게 독립적인 글”인지 인식하기 어렵다.

### 🔸 3. 유지보수/협업 문제

- 코드를 읽는 사람(개발자)이 구조를 이해하기 어려워짐.
- `<header>` / `<nav>` / `<footer>` 대신 `<div>`만 있으면 역할 구분이 힘듦.

### 🔸 4. 표준성/호환성 문제

- 웹 표준을 따르지 않으면 브라우저별/환경별로 다르게 동작할 가능성이 높아짐.
- 향후 기술(검색엔진/AI/보조기기)과 호환성 떨어짐.

# 브라우저 동작

## DOM 이란

DOM은 HTML 문서를 객체 기반 트리 구조로 표현한 모델로, JavaScript가 이를 조작해 동적인 웹 페이지를 만들 수 있게 해줍니다.

**DOM(Document Object Model)** 은

👉 “브라우저가 HTML, XML 문서를 객체(트리 구조)로 표현한 프로그래밍 인터페이스” 입니다.

- **Document** → 문서 (HTML, XML)
- **Object** → 문서의 각 요소를 객체로 표현
- **Model** → 문서 전체를 트리(Tree) 구조로 추상화

즉, 우리가 작성한 **HTML 태그들을 브라우저가 이해할 수 있도록 객체로 변환**한 구조가 DOM이에요.

## 📌 DOM 생성 & 조작 과정

**DOM은 HTML 문서를 트리 구조로 표현한 객체 모델입니다. 브라우저는 HTML을 파싱해 DOM Tree를 만들고, CSS와 결합해 Render Tree를 생성합니다. 이후 JavaScript로 DOM을 조작해 동적인 웹 페이지를 구현할 수 있습니다.**

### 1. HTML 파싱 (Parsing)

브라우저는 HTML 문서를 위에서 아래로 읽으면서 **DOM 트리(DOM Tree)** 를 만듭니다.

### 2. DOM 트리 (DOM Tree)

- `Document` 객체가 최상위(root)
- 각 태그(`<html>`, `<body>`, `<h1>` …)가 노드(node)로 표현됨
- 텍스트도 `"Hello"` 처럼 별도의 **텍스트 노드**로 존재

### 3. CSSOM과 결합 → Render Tree

- HTML에서 DOM Tree
- CSS에서 CSSOM Tree
- 두 개가 합쳐져 **Render Tree** 가 만들어짐 → 브라우저가 이걸 기반으로 화면을 그림(Paint)

## 4. JavaScript로 DOM 조작

DOM API를 통해 페이지 내용을 동적으로 바꿀 수 있습니다.

## **📌 CSSOM 생성 과정**

“CSSOM은 브라우저가 CSS를 토큰화 → 파싱 → 규칙 집합 생성 과정을 거쳐 트리 구조로 만든 것입니다. 이후 DOM과 결합해 Render Tree를 구성하고, 여기서 최종 스타일을 계산해 화면에 그립니다.”

### 1. CSS 리소스 로드 (Loading)

- HTML 파싱 중 `<link rel="stylesheet">`, `<style>`, `@import` 같은 **CSS 참조**를 만나면 브라우저는 CSS 파일을 가져옵니다.
- 외부 CSS는 네트워크 요청이 필요해서 **렌더링을 차단(blocking)** 하는 경우가 많습니다.

### 2. 토큰화 (Tokenization)

- 불러온 CSS 텍스트를 **토큰(token)** 으로 쪼갭니다.

### 3. 파싱 (Parsing)

- 토큰을 **노드(node)** 로 바꿔 **규칙(규칙 집합, Rule Set)** 을 만듭니다.

### 4. CSSOM 트리 생성 (Building the CSSOM Tree)

- 선택자와 선언들을 모아 **트리 구조로 저장**합니다.
- DOM처럼 부모-자식 관계는 아니지만, **스타일 상속/우선순위 계산**을 위해 계층적 구조를 가짐.

### 5. 스타일 계산 (Style Calculation)

- DOM과 CSSOM을 결합해서 각 요소에 **최종 스타일(Computed Style)** 을 계산합니다.
- 이때 **상속, 캐스케이딩(Cascading), 우선순위(Specificity)** 가 적용됩니다.
- 예: `p` 태그 → `font-size: 14px` (자신의 규칙) + `color: black` (body로부터 상속)

## Google.com을 입력했을 때 일어나는 일

# 1) 주소창에서의 해석/결정

1. 사용자가 `google.com` 입력
2. 브라우저가 **탐색 vs 검색**을 판별(히스토리/오토컴플릿/검색엔진 규칙).
3. 스킴이 없으므로 **HTTPS 시도**(대부분의 브라우저는 HTTPS 우선, HSTS 프리로드 도메인은 강제 업그레이드).
    
    → 최종 타깃: `https://google.com/` (필요 시 `www.` 리다이렉트 가능)
    

# 2) 네트워크 연결 준비

1. **DNS 조회**: 캐시(브라우저/OS/라우터/리졸버) → 없으면 재귀 조회로 `A/AAAA` 레코드 획득.
2. **연결 수립**
    - **HTTP/3 가능**: UDP 기반 **QUIC 핸드셰이크**(ALPN으로 `h3` 협상).
    - 아니면 **TCP 3-way** → **TLS 1.3 핸드셰이크**(SNI, ALPN으로 `h2`/`http/1.1` 결정).
    - 서버 인증서 검증(체인/만료/호스트명/OCSP 스테이플링, HSTS 위반 차단).

# 3) 요청 전 단계(브라우저 측)

1. **서비스 워커**: 해당 오리진에 등록되어 있고 범위가 매치되면 **네비게이션 요청을 가로채** 캐시/프리로드를 응답할 수 있음(첫 방문이면 보통 없음).
2. **HTTP 캐시**: 동일 URL이 캐시돼 있고 유효하면 바로 사용, 아니면 조건부 요청(ETag/Last-Modified).

# 4) 요청 전송

1. 예시: `GET / HTTP/2`
    - 주요 헤더: `Host`, `User-Agent`, `Accept*`, `Accept-Language`, `Cookie(있다면; SameSite/Secure 규칙)`, `Referer-Policy`에 따른 `Referer`.
    - 전송 최적화: HPACK/QPACK 압축, TCP/TLS 레벨에서는 TLS 레코드/패킷화.

# 5) 서버 측 처리(간략)

1. Anycast/CDN/LB를 거쳐 **가까운 엣지**로 라우팅 → 백엔드 선택.
2. 인증/리다이렉트/AB 테스트 결정 → HTML(또는 리다이렉트 301/302) 응답 생성.
    - 압축(`br`/`gzip`), 캐시 지시자(`Cache-Control`, `ETag`), 보안 헤더(CSP/HSTS/COOP/ CORP) 포함.

# 6) 응답 수신 & 리다이렉트

1. 브라우저가 **상태코드** 해석:
    - 200: 본문 처리
    - 301/302: 대상 URL로 재탐색(예: `https://www.google.com/` 지역도메인 등)
    - 304: 캐시 재사용

# 7) 렌더링 파이프라인(크리티컬 렌더링 패스)

1. **HTML 파싱 → DOM 생성**(프리로드 스캐너가 CSS/JS/프리커넥트 링크를 선요청).
2. **CSS 파싱 → CSSOM** (CSS는 렌더 차단)
3. **Render Tree = DOM + CSSOM** → **Layout(레이아웃)** → **Paint(페인트)** → **Composite(합성/GPU)**
4. **JS 실행**:
    - `<script>`는 기본 차단, `defer/async`로 비차단화 가능.
    - JS가 DOM/CSSOM에 접근하며 추가 네트워크 요청(Fetch/XHR, 모듈/다이내믹 임포트).
5. **폰트/이미지**: `font-display` 정책 따라 FOUT/FOIT, 이미지 디코딩/디퍼/레이징.
6. **보안/정책 적용**: SOP, CORS, Mixed Content 차단, CSP 위반 차단.

## SPA 프레임워크라면 HTML 로딩 후 JS가 DOM을 다시 구성

## 그냥 HTML에서 렌더링 하는거랑 어떤 과정에서 차이가 있어?

일반 HTML 렌더링은 브라우저가 문서를 그대로 파싱해 바로 화면을 그리지만, Vue 같은 SPA는 초기 HTML은 비어 있고 JS가 실행되어 Virtual DOM을 기반으로 DOM을 구성해야 화면이 나타납니다. 대신 한 번 로드되면 페이지 전환 시 서버 요청 없이 Virtual DOM만 갱신하므로 빠르고 동적인 UX를 제공합니다.

## ✅ 1. 일반 HTML 렌더링 (전통적 MPA, Multi Page Application)

1. 브라우저가 HTML 문서를 다운로드
2. HTML 파싱 → DOM 생성
3. CSS 파싱 → CSSOM 생성
4. JS 실행 (필요시 DOM 조작)
5. 바로 **렌더 트리(Render Tree) → Layout → Paint → 화면 표시**

👉 HTML 자체가 완성된 문서라서 **브라우저는 바로 그리기(Paint)** 할 수 있음.

👉 각 페이지 이동마다 서버에서 **새로운 HTML 문서**를 받아와 렌더링.

👉 JS는 “보조 역할”(동적 인터랙션, 검증 등)로 사용됨.

## ✅ 2. Vue 같은 SPA 렌더링

1. 브라우저가 `index.html`을 다운로드 → 보통 내용은 `<div id="app"></div>` 같은 최소 구조
2. JS 번들(Vue runtime + 앱 코드)을 다운로드 후 실행
3. Vue가 Virtual DOM 기반으로 **DOM 트리를 생성/마운트** → 실제 DOM에 반영
4. 이후 데이터 변경 시 → Virtual DOM diff → 실제 DOM에 최소 변경 반영

👉 HTML만으로는 초기 UI가 보이지 않고, **JS 실행이 끝나야 화면이 뜸** (CSR의 단점)

👉 페이지 이동 시 새 HTML 요청이 아닌, **라우터(Vue Router)와 Virtual DOM 갱신**으로 처리 → 새로고침 없이 부드러운 전환

👉 JS가 “메인 렌더링 엔진” 역할

## **쿠키, sessionStorage, localStorage의 차이점은 무엇인가요?**

쿠키, sessionStorage, localStorage는 모두 웹 브라우저에서 사용되는 데이터 저장방식입니다. 이 세가지의 주요한 차이점은 저장 용량, 데이터 유지기간, 그리고 데이터 접근성에 있습니다.

**쿠키**

- 쿠키는 서버와 클라이언트 간 상태 정보를 유지하거나 사용자의 이전 상태를 기억하기 위해 사용됩니다.
- 쿠키는 최대 4Kb의 데이터만을 저장할 수 있으며, 만료 날짜가 지나면 자동으로 삭제됩니다.
- 쿠키는 HTTP 헤더를 통해 서버와 클라이언트 간에 주고받을 수 있습니다.

**2. sessionStorage**

- 세션스토리지는 브라우저의 세션 동안만 데이터를 저장하게 됩니다.
    - 즉, 브라우저가 닫히면 데이터는 사라집니다.
- 저장용량은 브라우저마다 다르지만 일반적으로 5MB이상입니다.
- 세션 스토리지는 오직 자바스크립트를 통해서만 접근할 수 있습니다.

**3. localStorage**

- 로컬스토리지는 브라우저가 닫혀도 데이터가 유지되게 됩니다.
- 저장용량은 브라우저에 따라 다르지만 일반적으로 5MB ~ 10MB입니다.
- 로컬스토리지 또한 자바스크립트를 통해서만 접근할 수 있습니다.

**이처럼 세가지모두 장단점이 존재하며, 사용목적에 따라 적절히선택해야합니다.**

- 쿠키는 서버와 상호작용이 필요하거나 여러 도메인에서 정보를 공유해야하는 경우 사용합니다.(자동로그인 등)
- 세션스토리지는 임시데이터를 저장하거나 브라우저 세션동안 유지될 필요가 있는 정보를 저장하는 경우 사용합니다.(채팅 메시지, 실시간 업데이트 정보 등)
- 로컬스토리지는 클라이언트에 영구적으로 저장해야하는 정보를 저장하는 경우에 사용됩니다.(사용자 테마등)

## Repaint와 Reflow(Layout)의 차이점은 무엇인가요?

- **Repaint**: 요소의 스타일(색상, 배경, visibility 등)만 바뀌어 다시 그려야 하는 경우.
- **Reflow(Layout)**: 요소의 크기나 위치, 레이아웃 자체가 변해서 다시 계산해야 하는 경우.
- Reflow는 레이아웃 트리 재계산 → Render Tree 업데이트 → Paint 과정까지 이어짐.
- 따라서 Reflow는 더 무겁고, 빈번하면 성능 저하 발생.

## display: none과 visibility: hidden은 Reflow/Repaint 관점에서 어떤 차이가 있나요?

- display: none → 레이아웃에서 제외 → Reflow 발생
- visibility: hidden → 레이아웃 유지, 단순 스타일 변경 → Repaint만 발생

## 브라우저 렌더링 과정에서 언제 Repaint가 발생하나요?

**Repaint**는 **요소의 위치나 레이아웃에는 변화가 없고, 시각적인 스타일만 변경되었을 때** 발생합니다.

즉, 레이아웃 재계산(Layout, Reflow)은 필요 없지만, **픽셀을 다시 칠해야 하는 경우**에 브라우저가 Repaint를 수행합니다.

## Reflow가 Repaint보다 성능에 더 영향을 많이 주는 이유는 무엇인가요?

- **Repaint (화면 다시 칠하기)**
    - 요소의 **시각적 속성**만 변경될 때 발생 (예: color, background-color, opacity).
    - 레이아웃 트리(Layout Tree)나 위치 계산은 필요 없고, 단순히 픽셀을 다시 칠하면 끝.
    - 따라서 상대적으로 성능 부담이 적음.
- **Reflow (레이아웃 재계산)**
    - 요소의 크기(width, height), 위치, 구조에 변화가 생기면 전체 문서 흐름(Layout Tree)을 다시 계산해야 함.
    - DOM 트리 → Render Tree → Layout 계산 과정을 다시 수행 → 이후 Repaint까지 이어짐.
    - 특히 한 요소의 Reflow가 **부모·자식·형제 요소**까지 전파될 수 있어 비용이 매우 커짐.
    - 예: `display: none`, `position 변경`, `width/height 변경`.
- **비용 비교**
    - Repaint = 단순 시각적 갱신 (빠름).
    - Reflow = 레이아웃 트리 재계산 + Repaint까지 연쇄 발생 (느림).

## Reflow를 줄이기 위해 Virtual DOM이나 Vue같은 라이브러리에서는 어떤 방식으로 최적화할까요?

- **목표는 DOM 터치 최소화**: 레이아웃(Layout) 재계산을 유발하는 DOM 변경을 “최소 개수·최소 영역·최소 횟수”로 묶어 처리.
- **측정(읽기)과 변경(쓰기)의 분리**: 읽기→쓰기 순서로 배치해 **layout thrashing**(읽기·쓰기가 교차하며 강제 Reflow 유발)을 피함.
- **가능하면 페인트만 유발**: transform/opacity 같은 **compositor-friendly** 속성으로 애니메이션.

## W3C

W3C(World Wide Web Consortium)”는 웹 표준을 만드는 기구

## FOUC란?

FOUC는 Flash of Unstyled Content의 약자로, **웹 페이지에 스타일이 적용된 CSS 파일이 로드되기 전에, 스타일이 적용되지 않은 상태의 웹 페이지 내용이 잠시 보이는 현상**을 의미합니다.

### 해결방법 1. **CSS를 HTML 문서의 <head> 태그에 배치:**

브라우저는 HTML 문서를 순차적으로 해석하므로, 스타일을 가능한 한 빨리 로드하려면 <head> 태그 내에 <link> 태그를 사용하여 CSS 파일을 연결하는 것이 좋습니다. 이렇게 하면 브라우저가 렌더링을 시작하기 전에 스타일을 먼저 로드하고 적용할 수 있습니다.

### 해결방법 2. **인라인 CSS 사용**

우선, 인라인 CSS란  요소의 `style` 속성 안에 직접 작성 ← 이게 바로 인라인 CSS

인라인 스타일은 별도의 HTTP 요청 없이 페이지와 함께 로드되기 때문에 렌더링 속도가 빨라질 수 있습니다. 하지만 이 방법은 파일 크기가 커질 수 있으므로, 필수적인 스타일 정보만 인라인으로 삽입하는 것이 좋습니다. 이를 부분적으로 적용하기 위해크리티컬 CSS라는 기법을 사용할 수 있습니다.

> 
> 
> 
> 크리티컬 CSS란 웹 페이지의 초기 렌더링에 영향을 미치는 중요한 스타일을 인라인으로 삽입하는 방법입니다.
> 

## FOUT란?

flash of invisible text

웹 폰트를 사용하는 경우, 브라우저가 웹 폰트 파일을 다운로드하고 파싱하는데 시간이 걸릴 수 있습니다. 웹 폰트가 아직 로드되지 않았을 때, 브라우저는 시스템 기본 폰트를 사용하여 텍스트를 먼저 렌더링합니다. 웹 폰트가 로드되면, 브라우저는 렌더 트리를 업데이트하여 웹 폰트를 적용한 텍스트를 표시하게 됩니다. 이 과정에서 사용자는 잠시 웹 폰트가 적용되지 않은 텍스트를 볼 수 있게 됩니다.

### 해결방법

웹 폰트 로드 최적화:웹 폰트를 불러오는 방식을 최적화하면 FOUT 현상을 줄일 수 있습니다. 예를 들어, <link> 태그의 preload 속성을 사용하여 웹 폰트를 미리 로드할 수 있습니다. 또는 CSS font-display 속성을 사용하여 웹 폰트의 로드 및 렌더링 동작을 조절할 수 있습니다.

## FOUC, FOUT 발생하는 이유

브라우저는 HTML, CSS, JavaScript 파일을 로드하여 웹 페이지를 렌더링합니다. HTML은 페이지의 구조를 정의하고, CSS는 스타일을 적용하며, JavaScript는 동작을 추가합니다. 이 과정에서 브라우저는 다음 단계를 거칩니다.

- HTML 파싱: 브라우저는 HTML 파일을 파싱하여 DOM(Document Object Model) 트리를 생성합니다.
- CSS 파싱: 브라우저는 CSS 파일을 파싱하여 CSSOM(CSS Object Model) 트리를 생성합니다.
- 렌더 트리 생성: DOM 트리와 CSSOM 트리를 합쳐서 렌더 트리를 생성합니다. 이 트리는 페이지의 시각적 요소를 나타냅니다.레이아웃: 렌더 트리의 요소들에 대한 위치와 크기를 계산합니다.
- 페인팅: 최종적으로 스타일과 레이아웃 정보를 바탕으로 화면에 요소를 그립니다.

> FOUC와 FOUT 현상은주로 렌더 트리 생성 및 레이아웃 단계에서 발생합니다. 스타일 정보가 늦게 도착하거나, 웹 폰트가 로드되는 동안 브라우저가 기본 폰트로 렌더링하기 때문입니다.
> 
1. **HTML 파싱:** 브라우저는 HTML 파일을 파싱하여 DOM(Document Object Model) 트리를 생성합니다.
2. **CSS 파싱:** 브라우저는 CSS 파일을 파싱하여 CSSOM(CSS Object Model) 트리를 생성합니다.
3. **렌더 트리 생성:** DOM 트리와 CSSOM 트리를 합쳐서 렌더 트리를 생성합니다. 이 트리는 페이지의 시각적 요소를 나타냅니다.
4. **레이아웃:** 렌더 트리의 요소들에 대한 위치와 크기를 계산합니다.
5. **페인팅:** 최종적으로 스타일과 레이아웃 정보를 바탕으로 화면에 요소를 그립니다.

![](https://blog.kakaocdn.net/dna/bWUSQ9/btsdeHfNVRG/AAAAAAAAAAAAAAAAAAAAALvAq7yYeQ45V3JjT6fFoC4FjElnUINvgAPHp4AmANyB/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1756652399&allow_ip=&allow_referer=&signature=l2xP0UF8lE2e0x1WAVc%2BO0BZhWM%3D)

JavaScript 로드 순서 조절:JavaScript가 페이지의 스타일 적용을 차단하거나 렌더링을 지연시키는 경우, FOUC와 FOUT 현상이 발생할 수 있습니다. 따라서 JavaScript 로드 순서를 조절하여 문제를 해결할 수 있습니다. 스크립트를 HTML 문서의 <body> 태그 끝 부분에 배치하거나 async 또는 defer 속성을 사용하여 스크립트 로드 순서를 변경할 수 있습니다. 이렇게 하면 브라우저가 스크립트 로드를 지연시키고 스타일이 완전히 로드되고 적용된 후에 스크립트를 실행할 수 있습니다.