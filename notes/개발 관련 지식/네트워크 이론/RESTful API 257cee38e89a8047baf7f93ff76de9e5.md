---
title: RESTful API
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# RESTful API

# 권장되는 RESTFul API 설계

## API란?

응용프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스입니다. 
• API는 프로그램 끼리 통신할 수 있도록 하는 중간다리역할을 하게됩니다.

## REST와 RESTful API의 차이를 설명해보세요.

### REST (Representational State Transfer)

- **개념**: 2000년 로이 필딩(Roy Fielding)의 박사 논문에서 제안된 **아키텍처 스타일(설계 원칙)**입니다.
- **핵심 원칙**:
    1. **클라이언트-서버 구조** (Client-Server)
        
        → 역할을 분리하여 확장성과 유연성을 높임.
        
    2. **무상태성** (Stateless)
        
        → 서버는 요청 간의 상태를 저장하지 않음.
        
    3. **캐시 가능성** (Cacheable)
        
        → 응답은 캐싱이 가능해야 하며, 성능 최적화에 도움.
        
    4. **균일한 인터페이스** (Uniform Interface)
        
        → 자원을 URI로 식별, HTTP 메서드(GET, POST, PUT, DELETE 등)로 조작.
        
    5. **계층화 시스템** (Layered System)
        
        → 클라이언트는 서버의 내부 구조를 알 필요 없음.
        
    6. **코드 온 디맨드(선택 사항)** (Code on Demand)
        
        → 서버가 클라이언트에 실행 가능한 코드를 내려줄 수도 있음.
        

즉, REST는 **웹 아키텍처 설계 철학**입니다.

자원을 이름으로 구분해 해당 자원의 상태를 주고받는 모든것을 뜻합니다. `HTTP` `URI`를 통해 자원을 명시하고 `HTTP 메(POST,GET,PUT,PATCH,DELETE)`를 통해 해당 자원에 대한 `CRUD`를 구축합니다.

### RESTful API

- **개념**: REST의 원칙을 **충실히 지켜서 설계된 API**를 말합니다.
- 자원을 이름으로 구분해 해당 자원의 상태를 주고받음. 자원, 행위;, 표현 3가지 요소로 구성됨
- 중요한 원칙은 
1) URI는 리소스를 표현하는 방식
2) 행위에 대한 정의는 HTTP 요청 메서드를 통해 함
- **특징**:
    - 각 리소스(Resource)는 고유한 URI로 식별됩니다.
        
        예: `/users/123`
        
    - HTTP 메서드를 의미에 맞게 사용합니다.
        - `GET /users` → 사용자 목록 조회
        - `POST /users` → 사용자 생성
        - `PUT /users/123` → 사용자 정보 수정
        - `DELETE /users/123` → 사용자 삭제
    - 요청과 응답은 일반적으로 **JSON**이나 **XML** 형식 사용.
    - 클라이언트와 서버가 느슨하게 결합되어, 확장성과 유지보수성이 뛰어남.

## REST를 쓰는 이유는 무엇인가?

HTTP는 단순히 요청/응답을 주고받는 프로토콜이고, REST는 그 위에서 **리소스 중심 설계, HTTP 메서드 활용, 상태 코드, 무상태성** 같은 규칙을 정해 API를 더 일관적이고 확장성 있게 만들기 위한 아키텍처 스타일입니다. 그래서 단순히 HTTP만 쓰는 것보다 REST 원칙을 따르면 협업과 유지보수가 훨씬 좋아집니다

## JSON과 XML은 무엇이고, 둘의 차이점은 무엇인가?

REST API에서 JSON을 선호하는 이유는 XML보다 가볍고 직관적이며,

JavaScript와 호환성이 좋아 웹 환경에서 사용하기 쉽기 때문입니다.

또한 **파싱 속도가 빠르고 데이터 타입 지원이** 명확해 RESTful API의 사실상 표준이 되었습니다

## 1. JSON (JavaScript Object Notation)

- **정의**: 경량의 데이터 교환 형식. 자바스크립트 객체 표기법에서 파생됨.
- **특징**:
    - 사람이 읽고 쓰기 쉽고, 기계도 파싱하기 쉬움.
    - 데이터는 **Key-Value** 쌍으로 표현.
    - 대부분의 프로그래밍 언어에서 라이브러리로 바로 지원.
- **예시**:
    
    ```json
    {
      "user": {
        "id": 1,
        "name": "Alice",
        "email": "alice@example.com"
      }
    }
    
    ```
    

---

## 2. XML (eXtensible Markup Language)

- **정의**: 데이터 저장 및 교환을 위해 고안된 **마크업 언어**.
- **특징**:
    - 태그(`< >`)로 구조 표현.
    - 데이터와 메타데이터(속성) 표현 가능.
    - 문법이 엄격하고 무겁지만, 문서 구조와 계층을 명확히 표현 가능.
- **예시**:
    
    ```xml
    <user id="1">
      <name>Alice</name>
      <email>alice@example.com</email>
    </user>
    
    ```
    

---

## 3. JSON과 XML의 **공통점**

1. **데이터 교환 포맷**으로 사용 (API, 설정 파일 등).
2. **계층적 구조(트리 구조)** 표현 가능.
3. **사람이 읽을 수 있고 기계가 처리하기 쉬움.**
4. 언어나 플랫폼에 독립적임.

---

## 4. JSON과 XML의 **차이점**

| 구분 | JSON | XML |
| --- | --- | --- |
| 표현 방식 | Key-Value 쌍 (경량) | 태그 기반 (마크업) |
| 가독성 | 직관적, 짧고 단순 | 장황하고 복잡할 수 있음 |
| 데이터 타입 지원 | 문자열, 숫자, 배열, 객체 등 명시적 지원 | 전부 문자열, 타입 구분 없음 |
| 파싱 속도 | 빠름 (가볍고 단순) | 느림 (무겁고 복잡) |
| 메타데이터 표현 | 상대적으로 제한적 | 속성(Attribute)으로 가능 |
| 사용 분야 | REST API, 웹/모바일 앱 데이터 교환 | 문서 중심 데이터, SOAP, 설정 파일 등 |
| 무게 | 가볍다 (Lightweight) | 무겁다 (Verbose) |

---

## 5. ✅ 면접 답변 요약

> “JSON과 XML 모두 데이터 교환 포맷이고 계층 구조를 표현할 수 있습니다.
> 
> 
> JSON은 가볍고 읽기 쉬워서 **RESTful API에서 주로 사용**되고,
> 
> XML은 태그와 속성을 활용해 문서 구조와 메타데이터 표현에 강해서 **SOAP이나 설정 파일**에 자주 쓰입니다.”
> 

## 1. URL (Uniform Resource Locator)

- **리소스의 “위치”를 나타내는 주소**입니다.
- 흔히 말하는 웹 주소가 URL이에요.
- 구조:
    
    ```
    프로토콜://도메인:포트/경로?쿼리#프래그먼트
    
    ```
    
    예:
    
    ```
    https://www.example.com:443/users/123?active=true#info
    
    ```
    
    - `https` → 프로토콜
    - `www.example.com` → 도메인
    - `443` → 포트 (생략 가능)
    - `/users/123` → 경로 (리소스 위치)
    - `?active=true` → 쿼리 파라미터
    - `#info` → 프래그먼트(페이지 내부 특정 위치)

---

## 2. URI (Uniform Resource Identifier)

- **리소스를 식별하는 모든 방식**을 말하는 상위 개념.
- **URL**과 **URN**을 포함합니다.
    - URL: 위치 기반 식별자
    - URN: 이름 기반 식별자

즉, URL은 URI의 한 종류예요.

👉 “URL ⊂ URI”

---

## 3. URN (Uniform Resource Name)

- **위치와 상관없이 리소스를 이름으로 식별**하는 방식.
- 예:
    
    ```
    urn:isbn:0451450523
    
    ```
    
    (책 ISBN 번호로 특정 책을 가리킴 → 어디에 있든 상관 없음)
    

## RESTful API가 지켜야 할 제약조건(6가지)을 아는 대로 말해보세요.

RESTful API는 6가지 제약조건을 지켜야 합니다.

클라이언트-서버 구조, 무상태성, 캐시 가능성, 균일한 인터페이스, 계층화 구조, 마지막으로 선택적 제약조건인 Code on Demand입니다

## ❓ "URI에 복수형 명사를 쓰는 이유는 뭔가요?"

- **답변**:
    
    리소스 집합(Collection)을 표현하기 위해 복수형을 씁니다.
    
    - `/users` → 사용자 전체 (Collection)
    - `/users/123` → 특정 사용자 (Item)
        
        이렇게 하면 일관성이 있고, 직관적으로 “집합-개별 요소” 관계를 드러낼 수 있습니다.
        

### URI는 어떤 기준으로 계층 구조를 잡아야 하나요?"

- **답변**:
    
    리소스 간의 **종속 관계**를 반영해야 합니다.
    
    - 예: 주문 → 주문 안의 아이템
        - `/orders/15/items` → 주문 15번의 아이템들
        - `/orders/15/items/3` → 주문 15번의 세 번째 아이템
            
            이렇게 계층 구조를 잡으면 API 의미가 명확해집니다.
            

## URl 설계에서, 리소스를 표현할 때 명사를 사용하는 이유는 무엇인가요?

REST에서는 모든 것을 리소스로 보기 때문에 URI는 ‘무엇(명사)’을 표현해야 하고,

‘어떻게(동사)’는 HTTP 메서드로 표현합니다. 이렇게 하면 일관성, 직관성, 확장성이 좋아집니다.

## RESTful API는 **Stateless** 해야 한다고 하는데, 로그인/인증은 어떻게 처리할 수 있을까요?

- 서버는 상태를 들고 있지 않음 → **클라이언트가 매 요청마다 인증 정보(토큰)를 전송**
- 인증 정보는 주로 **HTTP 헤더**(예: `Authorization: Bearer <token>`)로 보냄
- 서버는 매번 이 토큰의 유효성만 검증하고, 별도의 세션 메모리를 유지하지 않음 → **Stateless 충족**

## JWT와 세션 기반 인증의 차이, 그리고 RESTful API에서는 어떤 걸 더 많이 쓰는지 설명해보세요.

세션 기반 인증은 서버가 상태를 저장해서 간단하지만 확장성이 떨어지고, JWT는 서버가 Stateless하게 동작해서 RESTful API에 더 적합합니다. 그래서 RESTful API에서는 JWT가 더 선호되지만, 보안을 위해 Refresh Token 전략을 함께 씁니다.

- RESTful API의 핵심 제약조건은 **Stateless**.
- 따라서 서버가 상태(세션)를 저장하지 않는 **JWT 기반 인증**이 더 많이 쓰입니다.
- 특히 **SPA(React, Vue 등) + 모바일 앱 + 서버 분산 환경**에서는 JWT가 사실상 표준.
- 다만 보안·무효화 이슈 때문에 **짧은 Access Token + Refresh Token (쿠키)** 구조로 보완하는 것이 일반적입니다.

## RESTful API에서 CORS 문제가 자주 발생하는데, 이를 해결하는 방법은 무엇인가요?

CORS는 서버가 **올바른 CORS 헤더**와 **OPTIONS 프리플라이트 응답** 을 제공하도록 설정하는 게 해법입니다.

쿠키/자격증명 사용 여부, 허용 오리진의 정확한 지정,

```
Vary: Origin
```

과

```
Max-Age
```

같은 운영 디테일을 함께 챙기면 대부분의 CORS 문제를 안정적으로 해결할 수 있습니다.

## OpenAPI 란 무엇인가?

**Open API Specification (OAS)**

**OpenAPI**는 요즘 실무에서 백엔드/프론트엔드 협업, API 문서화, 자동 코드 생성 등에 거의 표준처럼 쓰이고 있어서 면접에서도 자주 다뤄집니다.

OPEN API란 : 인터넷 이용자가 일방적으로 웹 검색 결과 및 사용자 화면 등을 제공받는 데 그치지 않고 직접 응용 프로그램과 서비스를 개발할 수 있도록 공개된 개발자를 위한 인터페이스입니

쉽게 말하면:

→ "이 API는 이런 URL을 호출하면, 이런 파라미터를 받고, 이런 JSON을 돌려줘요"를

**기계가 이해할 수 있는 JSON/YAML 문서**

로 작성하는 표준입니다.

# Axios 관련

## Axios란 무엇이고, `fetch API`와 어떤 차이가 있나요?

Axios는 XHR 기반의 외부 라이브러리이고, Fetch는 브라우저 내장 표준 API입니다. 둘 다 Promise 기반이지만, Axios는 **자동 JSON 파싱, 에러 처리, 인터셉터, 타임아웃, 업로드/다운로드 지원** 등 실무 편의 기능이 풍부합니다. Fetch는 기본 제공이라 추가 설치가 필요 없고 최신 환경에서 가볍게 쓰기 좋지만, **에러 처리나 타임아웃, 인터셉터** 같은 기능은 직접 구현해야 합니다.

## 인터셉터 관련 질문

Axios의 인터셉터는 요청과 응답을 가로채 공통 로직을 넣을 수 있는 기능입니다.

예를 들어, 요청 인터셉터에서 **JWT 토큰을 자동으로 헤더에 추가**

하고, 응답 인터셉터에서 **401 에러 시 자동 로그아웃 처리** 같은 작업을 할 수 있습니다.

## Axios로 GET 요청과 POST 요청을 보낼 때 차이점을 설명해보세요.

Axios에서 GET은

```
params
```

를 이용해 URL 쿼리스트링으로 데이터를 전송하고, POST는

```
data
```

를 body에 담아 보냅니다. GET은 주로 조회, POST는 생성/변경에 사용하며, 멱등성과 캐싱 측면에서 차이가 있습니다.

## JSON 말고 multipart/form-data나 파일 업로드를 할 때 Axios는 어떻게 활용하나요?

Axios에서 파일 업로드는 **FormData 객체를 생성해 파일과 데이터를 담고, `Content-Type: multipart/form-data` 헤더와 함께 전송** 합니다. 업로드 진행률은

```
onUploadProgress
```

옵션으로 추적할 수 있고, 브라우저는 boundary를 자동 처리하지만 Node.js 환경에서는

```
form-data
```

라이브러리를 활용해야 합니다.

## Axios에서 에러가 발생했을 때, 어떤 정보들을 확인할 수 있나요? (error.response, error.request, error.message)

Axios 에러 객체는 주로 네 가지를 확인할 수 있습니다.

- `error.response`: 서버가 응답했지만 실패(400~500 에러) → status, data, headers 확인 가능
- `error.request`: 요청은 보냈지만 서버 응답이 없을 때 (네트워크 문제 등)
- `error.message`: 에러 메시지 (타임아웃, 설정 오류 등)
- `error.config`: 요청 당시의 Axios 설정 (URL, 메서드, 헤더 등)

## Axios에러 처리 시, `ry...catch` 말고 `interceptor`를 활용하는 방법을 설명해보세요.

Axios 에러 처리는 try...catch 로 개별 처리할 수도 있지만,

**응답 인터셉터의 에러 핸들러를 활용하면 모든 요청의 에러를 공통적으로 처리** 할 수 있습니다.

예를 들어, 401이면 로그인 페이지로 리다이렉트, 500이면 에러 메시지를 띄우는 식으로 관리하면 중복 코드를 줄일 수 있습니다.

## 네트워크 에러와 서버 응답 에러를 어떻게 구분할 수 있나요?

> 서버 응답 에러: error.response가 존재 (status, data, headers 확인 가능)네트워크 에러: error.request는 있지만 error.response 없음 (응답 자체가 도착하지 않음)클라이언트 오류: 요청 구성 문제는 error.message로 확인
> 

## AJAX란 무엇인가?

**Ajax는 자바스크립트를 통해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신기능입니다.**

브라우저가 가지고 있는 `XMLHttpRequest` 객체를 통해 전체 페이지를 새로고치지 않고도 페이지 일부만을 위한 데이터를 로드하는 기법입니다.

- `AJAX`는 `HTML` 페이지 전체가 아닌 일부분만을 갱신할 수 있도록 서버에 `request`하므로 `JSON`이나 `XML`형태로 필요한 데이터만을 받아 갱신하게됩니다. 따라서 그만큼의 리소스를 아낄 수 있습니다.
- 그러나 단점도 존재하는데, 클라이언트가 서버에 데이터를 요청하는 클라이언트 풀링 방식을 사용하므로, 실시간 서비스를 만드는 것은 불가능합니다.
- `XMLHttpRequest` 객체를 통해 통신하는 경우 사용자에게 아무런 진행정보가 주어지지 않습니다.
    - 따라서 요청이 완료되지 않았는데 사용자가 페이지를 떠나거나, 오류가 발생할 수 있게됩니다.

## OAuth란?

**OAuth란 인터넷 사용자들이 비밀번호를 제공하지 않고, 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 개방형 표준 방법입니다.**

- 이러한 메커니즘은 현재 다양한 사이트에서 사용되고 있으며, 타사 애플리케이션 및 웹사이트의 계정에 대한 정보를 공유할 수 있도록 허용해줍니다.

**OAuth의 인증과정은 다음과 같습니다**

> 소비자 : 사용자 정보에 접근하고자 하는 측 -> 개발 중인 프로젝트 웹 애플리케이션 서비스 제공자 : 사용자 정보를 보유하고 있으며, 요청하는 정보를 제공하는 웹 애플리케이션
> 
1. 소비자가 서비스 제공자에게 요청토큰을 요청합니다.
2. 서비스 제공자가 소비자에게 요청토큰을 발급해줍니다.
3. 소비자가 사용자를 서비스 제공자로 이동시킵니다.(이 단계에서 사용자 인증이 수행됩니다)
4. 서비스 제공자가 사용자를 소비자로 이동시킵니다.
5. 소비자가 접근 토큰을 요청합니다.
6. 서비스 제공자가 접근토큰을 발급합니다.
7. 발급된 접근토큰을 통해 소비자에서 사용자 정보에 접근하게 됩니다.

## AJAX란?