---
title: HTTP/HTTPS
tags: []
created: ""
updated: ""
source: ""
status: draft
---
# HTTP/HTTPS

## 📌 기초 질문

- HTTP란 무엇이고, HTTPS와의 차이는 무엇인가요?
- HTTP는 어떤 특징을 가지고 있나요? (예: 비연결성, 무상태성 등)
- HTTPS에서 보안을 어떻게 보장하나요?
- SSL과 TLS의 차이는 무엇인가요?

## HTTP란 무엇이고, HTTPS와의 차이는 무엇인가요?

HTTP는 웹에서 데이터를 주고받는 프로토콜로, 암호화가 없어 보안에 취약합니다. 반면 HTTPS는 HTTP에 SSL/TLS 계층을 추가해 통신 내용을 암호화하고 서버 인증을 통해 보안을 강화한 프로토콜입니다. 기본 포트는 HTTP가 80, HTTPS가 443을 사용합니다. 현재는 사용자 정보 보호와 SEO 측면에서도 HTTPS가 표준처럼 사용되고 있습니다.

## ✅ HTTP란?

- **웹에서 클라이언트(브라우저)와 서버 간 데이터 통신에 사용되는 기본 프로토콜**입니다.
- 텍스트 기반 프로토콜이라 사람이 읽을 수 있는 구조로 요청(Request)과 응답(Response)을 주고받습니다.
- 예: `GET /index.html HTTP/1.1`

**특징**

- 연결 시 인증이나 암호화 과정이 없음 → 데이터가 평문(plain text)으로 전송됨
- 속도는 빠르지만 보안에 취약 (중간에서 패킷을 가로채면 내용 확인 가능)

---

## ✅ HTTPS란?

- HTTP에 **보안 계층(SSL/TLS)**을 더한 프로토콜입니다.
- 클라이언트와 서버 사이 통신을 암호화하여 데이터 도청, 변조, 위조를 방지합니다.

**특징**

- SSL/TLS를 이용해 **대칭키 암호화 + 공개키 기반 인증**을 수행

→  AWS의 경우, Route 53을 이용해 ACM에서 이를 연동함 

- 신뢰할 수 있는 기관(CA, Certificate Authority)으로부터 발급받은 인증서를 사용
- URL이 `https://`로 시작하며 브라우저에서 자물쇠 아이콘으로 표시

## HTTP는 어떤 특징을 가지고 있나요? (예: 비연결성, 무상태성 등)

HTTP는 **비연결성**과 **무상태성**을 가진 텍스트 기반 프로토콜입니다. 요청과 응답 단위로 동작하며, 각 요청은 독립적으로 처리됩니다. 이런 특성 덕분에 단순하고 확장성이 좋지만, 상태 유지가 필요할 때는 쿠키나 세션 같은 기술을 사용해 보완합니다.

## ✅ HTTP의 주요 특징

1. **비연결성(Connectionless)**
    - 클라이언트가 요청(Request)을 보내고, 서버가 응답(Response)을 반환하면 **연결을 끊습니다.**
    - 장점: 서버 자원을 효율적으로 사용
    - 단점: 매 요청마다 새로운 연결이 필요 → 오버헤드 발생 (→ HTTP/1.1부터 Keep-Alive 도입으로 개선)
2. **무상태성(Stateless)**
    - 각 요청은 독립적이며, **이전 요청의 상태를 저장하지 않습니다.**
    - 장점: 서버 설계 단순화, 확장성 ↑
    - 단점: 클라이언트 상태를 유지하려면 별도 기술 필요 → **쿠키, 세션, 토큰** 등으로 보완
3. **단순성과 유연성(Simple & Extensible)**
    - 텍스트 기반 프로토콜 → 사람이 읽고 쓰기 쉬움
    - *메서드(GET, POST, PUT, DELETE 등)**와 **헤더**를 통해 다양한 확장 가능
4. **무연결 지향 요청/응답 구조**
    - 요청(Request) → 응답(Response) 한 쌍으로 동작
    - 서버는 클라이언트 요청이 없으면 응답하지 않음 (즉, 푸시 구조 아님 → HTTP/2, SSE, WebSocket으로 보완)
5. **프로토콜 독립성**
    - 기본은 TCP/IP 기반, 포트 80 사용
    - 하지만 필요하면 다른 프로토콜 위에서도 구현 가능

## SSL과 TLS의 차이점?

SSL은 과거에 사용된 보안 프로토콜로, 현재는 취약점 때문에 더 이상 쓰이지 않습니다. TLS가 그 후속으로 표준화되어 현재 HTTPS에서 사용하는 보안 프로토콜은 전부 TLS입니다. 다만 관습적으로 SSL 인증서라고 부르지만 실제로는 TLS 인증서를 의미합니다.

## HTTPS가 동작하는 과정?

HTTPS는 SSL/TLS 프로토콜을 이용해 보안을 보장합니다. 이 때, 연결은 TCP 연결임. 

먼저 서버는 인증서를 클라이언트에 전달하고, 클라이언트는 이를 검증합니다. 그 후 비대칭키 방식을 이용해 안전하게 세션 키를 교환하고, 실제 데이터 전송은 대칭키 암호화로 처리합니다. 이렇게 해서 **인증서로 신뢰성 확보, 비대칭키로 안전한 키 교환(세션 키 교환), 대칭키로 빠른 데이터 암호화**가 이뤄집니다.

공신력있는 인증서의 정보는 브라우저 내부에 보관되어 있습니다. 

## HTTP/1.1, HTTP/2, HTTP/3의 차이점을 설명할 수 있나요?

HTTP/1.1은 요청/응답이 직렬적으로 처리되어 지연이 많았고, 이를 개선하기 위해 HTTP/2에서는 **이진 프로토콜, 헤더 압축, Multiplexing**을 도입해 성능을 크게 높였습니다. 하지만 TCP 기반이라 여전히 Head-of-Line Blocking 문제가 남아 있었는데, HTTP/3에서는 **QUIC(UDP 기반)**을 사용해 이 문제를 해결하고, 0-RTT 같은 기능으로 더 빠른 연결을 제공합니다.

## ✅ HTTP/1.1

- **특징**
    - 요청/응답 기반의 전통적인 구조
    - 한 연결당 한 요청만 처리 가능 → **Head-of-Line Blocking(HoLB)** 문제
    - Keep-Alive로 연결 유지 가능하지만, 동시에 여러 요청을 효율적으로 처리하기 어려움
- **단점**
    - 리소스가 많은 웹페이지(이미지, JS, CSS 등)에서는 요청 지연 발생
    - 성능을 개선하려고 “도메인 샤딩, 스프라이트 이미지” 같은 편법을 많이 사용

---

## ✅ HTTP/2

- **특징**
    - **이진(Binary) 프로토콜** → 파싱 속도 ↑
    - **Multiplexing(다중화)**: 하나의 연결에서 여러 요청/응답을 동시에 처리 가능 → HoLB 문제 완화
    - **Header Compression (HPACK)**: 중복되는 헤더를 압축하여 네트워크 효율성 향상
    - **Server Push**: 클라이언트 요청 없이도 서버가 리소스를 미리 전송 가능
- **장점**
    - 지연 시간 감소, 네트워크 자원 효율적 사용

---

## ✅ HTTP/3

- **특징**
    - **TCP 대신 QUIC(UDP 기반)** 사용
    - TCP의 연결 지연(3-way handshake)과 전송 지연을 줄임
    - **0-RTT 연결**: 재접속 시 핸드셰이크 없이 바로 데이터 전송 가능
    - **스트림 독립성**: HTTP/2에서는 여전히 TCP 레벨에서 HoLB 문제가 있었는데, HTTP/3에서는 각 스트림이 독립적 → 지연 최소화
- **장점**
    - 모바일·무선 환경에서 안정적 (패킷 손실에도 전체 지연 최소화)
    - 유튜브, 구글, 페이스북 등에서 이미 널리 사용 중
    

## 프로토콜 발전이 실제 서비스 배포(CDN)에서 어떤 이점을 주는가?

CDN은 전 세계에 분산된 서버를 통해 사용자와 가까운 곳에서 콘텐츠를 제공해 지연을 줄입니다. HTTP/2에서는 Multiplexing 덕분에 도메인 샤딩 같은 편법이 필요 없어지고, 헤더 압축까지 적용되어 CDN 효율이 높아졌습니다. HTTP/3는 QUIC 기반이라 모바일 환경에서 특히 강점이 있고, 0-RTT 연결로 CDN 엣지 서버에서 빠르게 응답할 수 있습니다. 현재 Cloudflare, Akamai, AWS 같은 주요 CDN들이 HTTP/2와 HTTP/3를 적극 지원하고 있습니다.

## ✅ CDN과 HTTP/2

- **CDN 기본 역할**
    - 전 세계에 분산된 엣지 서버에 콘텐츠를 캐싱해, 사용자와 가까운 서버에서 응답 → 지연(latency) 감소.
- **HTTP/2와 CDN**
    - **Multiplexing** 덕분에 여러 리소스를 동시에 받아올 수 있어 웹 성능 향상.
    - 과거 HTTP/1.1에서는 “도메인 샤딩(domain sharding)” 기법을 썼지만, HTTP/2에서는 필요 없음.
    - 많은 CDN 업체(Akamai, Cloudflare, AWS CloudFront 등)가 HTTP/2를 지원해 성능 최적화.

---

## ✅ CDN과 HTTP/3

- **QUIC + UDP 기반 전송**
    - TCP 3-way handshake가 필요 없으므로, CDN 엣지 서버에서 **0-RTT 연결** 지원 → 더 빠른 응답.
    - 모바일 네트워크처럼 패킷 손실이 잦은 환경에서도 안정적 성능 보장.
- **실무 사례**
    - Google, YouTube, Facebook은 이미 HTTP/3를 적용.
    - Cloudflare 같은 CDN은 HTTP/3 지원을 활성화할 수 있음 → 브라우저(Chrome, Firefox, Safari 등) 지원도 확산 중.
- **장점**
    - 글로벌 서비스에서 지리적 지연(latency) 감소 + 손실 환경에서 더 좋은 사용자 경험 제공.

## 브라우저에서 HTTPS 인증서가 만료되었을 때 어떤 일이 일어나나요?

HTTPS 인증서가 만료되면 브라우저는 그 사이트를 더 이상 신뢰하지 않아 보안 경고 페이지를 띄웁니다. 이는 SSL/TLS 핸드셰이크 과정에서 인증서 유효성 검증에 실패했기 때문입니다. 사용자가 강제로 접속할 수는 있지만, 안전하지 않으므로 일반적으로 접속이 차단됩니다. 따라서 서비스 운영 시에는 인증서 만료를 방지하기 위해 자동 갱신이나 사전 모니터링을 반드시 적용합니다

## CDN이란?

CDN은 콘텐츠 전송 네트워크로, 전 세계에 분산된 엣지 서버에 콘텐츠를 캐싱해서 사용자가 가장 가까운 서버에서 빠르게 데이터를 받을 수 있게 합니다. 이를 통해 **속도 향상, 서버 부하 분산, 가용성 확보, 보안 강화** 효과가 있으며, Cloudflare, Akamai, AWS CloudFront 같은 서비스가 대표적인 예시입니다.

## ✅ CDN의 장점

1. **속도 향상**
    - 지리적 거리 단축 → 레이턴시 감소
    - 정적 파일(JS, CSS, 이미지, 동영상 등) 응답 속도 ↑
2. **서버 부하 분산**
    - 원본 서버로 가는 트래픽 감소 → 서버 비용 절약
3. **가용성 향상**
    - 특정 서버 장애 시 다른 엣지 서버에서 제공 가능
4. **보안 강화**
    - DDoS 방어, HTTPS 오프로딩, WAF(Web Application Firewall) 같은 기능 제공

## HTTP 요청 메서드(GET, POST, PUT, DELETE 등)의 차이를 설명해보세요.

HTTP 메서드는 클라이언트의 의도를 나타냅니다.

**GET은 조회, POST는 생성, PUT은 전체 수정, PATCH는 부분 수정, DELETE는 삭제**에 사용됩니다.

GET과 PUT, DELETE는 보통 **멱등성** 을 가지지만, POST는 멱등하지 않아 같은 요청을 여러 번 보내면 다른 결과가 발생할 수 있습니다

> 멱등이란 어떤 연산을 여러 번 실행해도 최종 결과가 변하지 않는 성질을 말합니다
> 

## ✅ 주요 HTTP 메서드와 특징

1. **GET**
    - **목적**: 리소스 조회(Read)
    - **특징**:
        - 요청 데이터를 **쿼리스트링(URL에 노출)**으로 전달
        - 브라우저 캐싱 가능
        - **멱등(Idempotent)** → 같은 요청 여러 번 보내도 결과 동일
    - 예: `/users?id=1` → 사용자 정보 조회

---

1. **POST**
    - **목적**: 리소스 생성(Create)
    - **특징**:
        - 요청 데이터를 **본문(Body)**에 담아 전송
        - URL에 노출되지 않음 → 보안 측면에서 GET보다 유리
        - **멱등하지 않음** → 같은 요청을 여러 번 보내면 데이터가 중복 생성될 수 있음
    - 예: `/users` + `{ name: "홍길동" }` → 새로운 사용자 등록

---

1. **PUT**
    - **목적**: 리소스 전체 수정(Update)
    - **특징**:
        - 요청 데이터 전체로 기존 리소스를 교체
        - **멱등** → 같은 요청 여러 번 보내도 결과 동일
    - 예: `/users/1` + `{ name: "홍길동", age: 30 }` → ID 1번 사용자의 정보 전체를 수정

---

1. **PATCH**
    - **목적**: 리소스 일부 수정(Update)
    - **특징**:
        - PUT과 달리 **리소스의 일부만 변경**
        - 멱등성이 보장되지 않을 수도 있음
    - 예: `/users/1` + `{ age: 31 }` → ID 1번 사용자의 나이만 수정

---

1. **DELETE**
    - **목적**: 리소스 삭제(Delete)
    - **특징**:
        - 서버에서 해당 리소스 제거 요청
        - **멱등** → 같은 요청 여러 번 보내도 결과는 동일 (삭제된 상태 유지)
    - 예: `/users/1` → 사용자 ID 1 삭제

---

## HTTP Keep-Alive 옵션은 무엇이고, 어떻게 성능을 개선하나요?

HTTP는 비연결성이라 매 요청마다 TCP 연결을 새로 맺어야 하는데, Keep-Alive는 연결을 재사용해서 여러 요청을 처리할 수 있게 해줍니다. 덕분에 TCP/TLS 핸드셰이크 오버헤드가 줄어들고 성능이 개선됩니다. 다만 직렬 처리라 Head-of-Line Blocking 문제는 여전히 남아, HTTP/2부터는 Multiplexing으로 개선되었습니다.

- 하나의 TCP 연결을 끊지 않고 **여러 개의 HTTP 요청/응답을 재사용**할 수 있게 해주는 기능
- 즉, **요청마다 새로 TCP 연결(3-way handshake)하는 오버헤드**를 줄여줌

## ✅ TCP (Transmission Control Protocol)

- **연결 지향적 (Connection-oriented)**
    - 통신 전 **3-way Handshake**로 연결을 맺고 시작
- **신뢰성 보장**
    - 패킷 손실 시 재전송, 순서 보장, 오류 검사 제공
- **흐름 제어 / 혼잡 제어 지원**
    - 네트워크 혼잡 시 속도 조절
- **속도는 느리지만 안정적**
- **사용 예시**
    - 웹(HTTP/HTTPS), 이메일(SMTP, IMAP), 파일 전송(FTP) 등 **데이터 정확성이 중요한 서비스**

---

## ✅ UDP (User Datagram Protocol)

- **비연결성 (Connectionless)**
    - Handshake 과정 없음, 그냥 패킷 전송
- **신뢰성 보장 안 함**
    - 순서 뒤바뀔 수 있음, 손실될 수 있음, 재전송 없음
- **오버헤드가 적고 빠름**
    - 실시간성 요구되는 서비스에 적합
- **사용 예시**
    - 스트리밍(영상/음성), 온라인 게임, DNS 조회, VoIP 등 **속도가 중요한 서비스**

## CDN을 사용할 때 HTTP/HTTPS 설정에서 주의할 점은 무엇인가요?

CDN에서 HTTPS를 사용할 때는 인증서 관리가 가장 중요합니다. 엣지 서버에도 인증서를 배포해야 하고, 자동 갱신을 설정하지 않으면 만료로 장애가 발생할 수 있습니다. 또한 HTTP 요청은 HTTPS로 리다이렉트해야 하며, TLS는 1.2 이상만 허용하는 것이 안전합니다. 마지막으로 CDN과 원본 서버 사이도 HTTPS를 적용해 전체 구간을 보호해야 하며, 캐싱 시 보안 헤더를 함께 설정해야 합니다

## HTTP 헤더에서 Cache-Control, ETag, Set-Cookie 같은 것들의 역할은 무엇인가요

`Cache-Control`은 리소스의 캐싱 정책을 지정하는 헤더로, 성능 최적화에 중요합니다. `ETag`는 리소스의 버전 태그를 제공해 변경 여부를 효율적으로 확인할 수 있고, `Set-Cookie`는 서버가 클라이언트에 상태 정보를 저장해 인증이나 세션 관리에 활용됩니다

## 동일출처정책 (Same origin Policy)란 무엇이며, 왜 필요한가?

동일 출처 정책은 브라우저의 보안 메커니즘으로, 프로토콜·호스트·포트가 다른 출처 간 리소스 접근을 제한하는 규칙입니다. 이를 통해 악성 사이트가 사용자의 인증 정보나 데이터에 무단으로 접근하는 것을 막을 수 있습니다. 다만 정당한 교차 출처 요청이 필요한 경우에는 서버가 CORS를 통해 예외를 허용할 수 있습니다.

- **출처(Origin)** = `프로토콜 + 호스트(도메인) + 포트`
- SOP는 **브라우저 보안 정책**으로,
    
    “한 출처에서 불러온 문서나 스크립트가 **다른 출처의 리소스에 접근하는 것을 제한**한다”는 규칙이에요
    
- **악성 스크립트로부터 사용자를 보호**하기 위해 필요합니다.
- 만약 SOP가 없다면?
    - 내가 로그인한 은행 사이트 쿠키가 브라우저에 저장되어 있다고 가정
    - 다른 악성 사이트(`evil.com`)이 자바스크립트로 `bank.com`에 요청을 보내고, 내 쿠키가 자동 포함되어 응답을 읽을 수 있다면? → 계좌 정보 유출, CSRF, 세션 탈취 발생
- SOP 덕분에 이런 **교차 출처 공격(Cross-Origin Attack)**을 차단할 수 있습니다.

## ✅ SOP의 적용 범위

- **제한되는 것**:
    - 다른 출처의 DOM 접근
    - 다른 출처의 쿠키/스토리지 접근
    - AJAX 요청 응답 데이터 접근 (단, 요청 자체는 보낼 수 있음 → 단 응답 차단)
- **허용되는 것** (예외)
    - `<img>`, `<script>`, `<link>` 같은 리소스 로드 (단순 삽입)
    - JSONP 같은 우회 기법 (과거)
    - **CORS**: 서버가 명시적으로 허용했을 때 교차 출처 리소스 접근 가능

## Preflight란 무엇인가?

Preflight는 CORS 상황에서 브라우저가 보내는 **사전 검증 요청**입니다. OPTIONS 메서드를 사용해서 서버가 해당 Origin, 메서드, 헤더를 허용하는지 확인하고, 허용되면 실제 요청을 보냅니다. 이렇게 함으로써 보안상 위험한 교차 출처 요청을 서버가 명시적으로 허용했을 때만 실행할 수 있습니다.

Preflight는 CORS와 관련된 개념으로, 브라우저가 보안상 안전하지 않은 요청을 보낼 때 먼저 서버에 OPTIONS 메서드로 허용 여부를 확인하는 과정입니다. 예를 들어 `PUT`이나 `DELETE` 같은 메서드, `Content-Type: application/json` 요청, 또는 Authorization 헤더가 포함된 요청에서 Preflight가 발생합니다

## CORS란 무엇인가?

CORS는 브라우저의 동일 출처 정책 때문에 발생하는 제약을 해결하기 위한 메커니즘입니다. 클라이언트가 다른 출처로 요청을 보낼 때, 서버가 `Access-Control-Allow-Origin` 같은 헤더를 내려주면 브라우저가 이를 확인하고 요청을 허용합니다. 즉, 보안은 유지하면서도 필요한 경우 교차 출처 리소스를 공유할 수 있도록 해줍니다.

## ✅ CORS란?

- *CORS(Cross-Origin Resource Sharing)**는 **브라우저의 보안 정책인 동일 출처 정책(Same-Origin Policy, SOP)** 때문에 제한된 **다른 출처(origin) 간의 리소스 공유를 허용하는 방법**입니다.
- 즉, 기본적으로 브라우저는 **출처(프로토콜 + 도메인 + 포트)**가 다르면 요청을 차단하지만, 서버가 명시적으로 허용하면 요청을 허용합니다.

---

## ✅ 왜 필요한가?

- 보안 이유: 악성 스크립트가 사용자 인증 정보를 훔치거나 임의의 요청을 보내는 것을 방지
- 하지만 실제 서비스에서는 **API 서버와 프론트엔드 서버가 분리**된 경우가 많음 → 이때 정상적인 교차 요청을 허용할 방법이 필요 → CORS 등장

---

## ✅ 동작 원리

1. **브라우저가 요청 전송**
    - `Origin` 헤더에 요청 출처를 포함
    - 예: `Origin: https://frontend.com`
2. **서버 응답**
    - `Access-Control-Allow-Origin` 헤더로 허용할 출처를 명시
    - 예: `Access-Control-Allow-Origin: https://frontend.com`
    - 혹은 모든 출처 허용 시
3. **브라우저 검증 후 요청 허용**

## Preflight 관련 헤더

- **`Origin`**
    - 요청을 보낸 도메인 정보 (예: `https://example.com`)
- **`Access-Control-Allow-Origin` →  응답헤더**
    - 서버가 허용하는 Origin 명시 ( 또는 특정 도메인)
- **`Access-Control-Allow-Methods` → 응답헤더**
    - 허용되는 메서드 지정 (예: `GET, POST, PUT`)
- **`Access-Control-Allow-Headers`**
    - 클라이언트가 보낼 수 있는 커스텀 헤더 지정
- **`OPTIONS` 요청 (Preflight)**
    - 브라우저가 실제 요청 전에 서버에 허용 정책을 확인하는 사전 요청
    
    **교차 출처**에서**비-단순 요청**
    
    ```
    Content-Type: application/json
    ```
    
    을 보내기 전에 브라우저가 **자동으로** OPTIONS를 보내 **서버가 허용하는지** 확인합니다.
    

## ✅ 언제 발생하나?

Preflight 요청은 모든 요청에서 발생하지 않고, **“Simple Request” 조건을 벗어날 때** 발생합니다.

즉, **안전하지 않은 요청**일 때 브라우저가 보안 확인 차원에서 수행합니다.

**Simple Request 조건** (Preflight 없이 바로 요청 가능):

- 메서드가 `GET`, `POST`, `HEAD` 중 하나
- `Content-Type`이 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain` 중 하나
- 커스텀 헤더 없음

➡ 이 조건을 벗어나면 Preflight 발생

## HTTP 1.1의 **Persistent Connection**과 HTTP/2의 **Multiplexing** 차이는 무엇인가요?

HTTP/1.1의 Persistent Connection은 단순히 하나의 TCP 연결을 여러 요청에 재사용하는 방식이라 성능은 개선되지만, 여전히 요청이 직렬 처리되어 Head-of-Line Blocking 문제가 발생합니다. 반면 HTTP/2는 Multiplexing을 도입해 하나의 TCP 연결에서 여러 요청과 응답을 동시에 병렬로 주고받을 수 있어 훨씬 효율적입니다

## ✅ HTTP/1.1 Persistent Connection (Keep-Alive)

- 기본적으로 HTTP는 **비연결(Connectionless)** → 요청/응답마다 TCP 연결을 새로 맺음
- **Persistent Connection**이 등장하면서,
    - 하나의 TCP 연결을 여러 요청에 재사용 가능
    - 즉, 매번 TCP 3-way handshake를 하지 않아도 됨
- **한계**:
    - 한 연결에서 동시에 하나의 요청만 처리 가능
    - 여러 요청을 보낼 경우 **직렬 처리(Queue)**
    - → 앞 요청이 느리면 뒤 요청이 지연되는 **Head-of-Line Blocking(HoLB)** 발생

---

## ✅ HTTP/2 Multiplexing

- HTTP/2에서는 **하나의 TCP 연결 위에서 여러 요청/응답을 동시에 병렬 처리** 가능
- 요청/응답을 **작은 프레임 단위로 쪼개서 전송** → 서로 다른 스트림이 독립적으로 흐름 유지
- **장점**:
    - HoLB 문제 완화
    - 다수의 리소스를 동시에 가져올 수 있어 페이지 로딩 속도 개선
    - 도메인 샤딩 같은 편법 불필요

## 기본적인 HTTP 응답 코드

## ✅ HTTP 상태 코드 분류 및 주요 코드

### 1. **1xx: Informational (정보)**

- 요청을 잘 받았고, 처리 중임을 의미
- **100 Continue**: 클라이언트가 요청을 계속 진행해도 됨
- **101 Switching Protocols**: 프로토콜 전환 (예: WebSocket 업그레이드)

---

### 2. **2xx: Success (성공)**

- 요청이 정상적으로 처리됨
- **200 OK**: 성공적인 요청 (가장 일반적)
- **201 Created**: 새로운 리소스가 생성됨 (POST 요청 시 자주 사용)
- **204 No Content**: 요청은 성공했지만 응답 본문 없음

---

### 3. **3xx: Redirection (리다이렉션)**

- 추가 동작(다른 URL 요청 등)이 필요함
- **301 Moved Permanently**: 리소스가 영구적으로 이동 (SEO에서 중요)
- **302 Found**: 임시 리다이렉트
- **304 Not Modified**: 캐시된 리소스를 그대로 사용 (ETag, If-None-Match 등과 함께 활용)

---

### 4. **4xx: Client Error (클라이언트 오류)**

- 클라이언트 잘못으로 요청 실패
- **400 Bad Request**: 잘못된 요청 (파라미터 오류 등)
- **401 Unauthorized**: 인증 필요 (토큰 없거나 잘못됨)
- **403 Forbidden**: 권한 없음 (인증은 했지만 접근 권한 없음)
- **404 Not Found**: 요청한 리소스 없음
- **405 Method Not Allowed**: 지원하지 않는 HTTP 메서드 사용

---

### 5. **5xx: Server Error (서버 오류)**

- 서버에서 요청 처리 중 문제 발생
- **500 Internal Server Error**: 서버 내부 오류 (일반적인 에러)
- **502 Bad Gateway**: 게이트웨이/프록시가 잘못된 응답 수신
- **503 Service Unavailable**: 서버 과부하, 점검 등으로 서비스 불가
- **504 Gateway Timeout**: 게이트웨이가 응답을 제때 받지 못함

## 브라우저 주소창에 URL을 입력하면 일어나는 일을 네트워크부터 브라우저 렌더링까지 설명해보세요

브라우저 주소창에 URL을 입력하면, 먼저 DNS 조회로 도메인에 해당하는 IP를 찾고 TCP 연결을 맺습니다. HTTPS라면 TLS 핸드셰이크도 거칩니다. 이후 브라우저가 서버에 HTTP 요청을 보내고, 서버가 HTML 응답을 반환하면 브라우저는 이를 파싱해 DOM과 CSSOM을 만들고 Render Tree를 생성합니다. 이후 레이아웃 계산과 페인팅, 레이어 합성을 거쳐 최종 화면을 렌더링합니다

## ✅ 1. 네트워크 계층: 요청 준비

1. **URL 파싱**
    - 브라우저가 URL을 분석해 프로토콜(`http/https`), 호스트명, 포트, 경로 등을 구분
2. **DNS 조회**
    - 입력한 도메인(`www.example.com`)을 실제 서버 IP로 변환
    - 로컬 캐시 → OS 캐시 → DNS 서버 순으로 탐색
3. **TCP 연결 (3-way Handshake)**
    - 브라우저와 서버가 TCP 연결을 설정 (신뢰성 있는 통신 준비)
    - HTTPS인 경우 → 추가로 **TLS 핸드셰이크** 진행 (인증서 검증, 세션키 교환)

---

## ✅ 2. 서버와 통신: 요청/응답

1. **HTTP 요청 전송**
    - 브라우저가 `GET /index.html` 요청과 함께 필요한 헤더(`Host`, `User-Agent`, `Cookie` 등)를 서버에 전송
2. **서버 처리 & 응답**
    - 서버는 요청을 처리하고, **HTTP 응답 메시지**(`status code`, `response headers`, `HTML body`)를 반환

---

## ✅ 3. 브라우저 렌더링 과정

1. **HTML 파싱 & DOM 생성**
    - 브라우저가 HTML 문서를 파싱해 **DOM 트리** 구축
2. **CSS 파싱 & CSSOM 생성**
    - CSS 파일을 다운로드하고 파싱 → **CSSOM(CSS Object Model)** 생성
3. **JS 파싱 & 실행**
    - `<script>` 태그 만나면 JS 엔진이 실행
    - `defer/async` 여부에 따라 HTML 파싱 차단 여부 달라짐
4. **Render Tree 생성**
    - DOM + CSSOM 결합 → **Render Tree** 생성
    - 실제 화면에 그릴 요소와 스타일 계산
5. **Layout (Reflow)**
- 각 요소의 크기, 위치 계산
1. **Painting (Rasterization)**
- 픽셀 단위로 화면에 그리기
1. **Compositing**
- 레이어를 합성해 최종적으로 화면에 렌더링

## 캐시가 있으면 DNS / TCP 연결 / 리소스 요청 과정이 생략되는데, 그 이유는 무엇인가?

브라우저는 여러 단계에서 캐시를 사용합니다. DNS 결과를 캐싱하면 도메인-IP 해석이 생략되고, TCP와 TLS 연결도 재사용할 수 있어 핸드셰이크를 반복하지 않습니다. 마지막으로 브라우저 캐시나 CDN 캐시에 리소스가 있으면 서버에 요청하지 않고 바로 응답을 가져올 수 있습니다. 이렇게 다층적인 캐시 덕분에 네트워크 왕복이 줄고 성능이 크게 향상됩니다.

## ✅ 1. DNS 캐시

- **위치**: 브라우저 → OS → 로컬 DNS 리졸버 → ISP DNS 서버 순으로 확인
- **동작**: 도메인-IP 매핑 결과를 TTL(Time To Live) 동안 저장
- **효과**:
    - 캐시에 있으면 매번 DNS 서버에 질의할 필요 없음 → **DNS 조회 생략**
- **예시**: `www.example.com`의 IP가 로컬 DNS 캐시에 살아 있다면, 바로 TCP 연결 시도

---

## ✅ 2. TCP 연결 재사용 (커넥션 캐시)

- **HTTP/1.1 Keep-Alive**
    - 일정 시간 동안 같은 서버와의 TCP 연결을 유지 → **재연결 불필요**
- **HTTP/2 / HTTP/3**
    - 하나의 연결에서 여러 요청을 동시 처리 (Multiplexing)
    - 따라서 추가 TCP 핸드셰이크 필요 없음
- **효과**:
    - 동일 서버로 여러 리소스를 가져올 때 연결 오버헤드 절감

---

## ✅ 3. TLS 세션 재사용 (세션 캐시 / 세션 티켓)

- HTTPS에서는 TCP 위에 TLS 핸드셰이크가 추가되는데, 이 역시 비용이 큼
- **세션 캐시(Session Cache)**, **세션 티켓(Session Ticket)**을 사용해 이전에 합의한 세션 키를 재사용 가능
- TLS 1.3에서는 **0-RTT 재연결** 지원 → 핸드셰이크 과정 생략하고 즉시 데이터 전송
- **효과**:
    - 재접속 시 암호화 핸드셰이크 오버헤드 제거

---

## ✅ 4. 리소스 캐시 (HTTP 캐시)

- **브라우저 캐시, 프록시 캐시, CDN 캐시** 등 다층 구조
- **제어 헤더**: `Cache-Control`, `ETag`, `Expires`, `Last-Modified`
- **효과**:
    - 캐시에 유효한 리소스가 있으면 서버에 요청 자체를 안 보냄 → **리소스 요청 생략**
    - 혹은 조건부 요청(If-None-Match)으로 변경 없을 시 `304 Not Modified`만 받아옴

---

## ✅ 정리

- **DNS 캐시** → 도메인 해석 과정 생략
- **TCP/TLS 캐시** → 연결 및 핸드셰이크 생략
- **HTTP 캐시** → 리소스 요청/다운로드 생략

즉, 캐시가 잘 활용되면 브라우저는 실제 네트워크 왕복을 최소화하고, **거의 로컬 리소스 로딩 수준 속도**로 페이지를 보여줄 수 있습니다.

## TCP 와 UDP 연결의 차이점?

TCP는 연결 지향적이고 패킷의 순서와 신뢰성을 보장하지만 속도가 느리고, UDP는 비연결형이라 빠르지만 신뢰성을 보장하지 않습니다. 그래서 TCP는 HTTP나 이메일처럼 정확성이 중요한 서비스에, UDP는 스트리밍이나 게임처럼 지연이 적어야 하는 서비스에 주로 사용됩니다

## 실무에서 SOP로 인한 자주 겪는 문제들

실무에서는 프론트엔드와 백엔드가 서로 다른 도메인이나 포트를 사용할 때 SOP 때문에 CORS 에러가 자주 발생합니다. 예를 들어 `localhost:3000`에서 `api.example.com`을 호출하면 브라우저가 차단하죠. 이를 해결하려면 서버에서 `Access-Control-Allow-Origin`을 설정하거나, 개발 환경에서는 프록시를 사용합니다. 또 쿠키를 공유할 때는 `Access-Control-Allow-Credentials`와 `SameSite=None; Secure` 옵션을 맞춰줘야 합니다

### 1. **API 서버와 프론트엔드 서버가 다른 출처일 때 (CORS 에러)**

- 예:
    - 프론트엔드: `http://localhost:3000`
    - 백엔드 API: `http://api.example.com:8080`
- 브라우저 기준으로는 **프로토콜, 도메인, 포트** 중 하나라도 다르면 “다른 출처”
- → 이 경우 `fetch`나 `axios` 요청이 브라우저에서 차단됨
- **해결 방법**:
    - 백엔드 서버에 `Access-Control-Allow-Origin` 헤더 설정
    - 개발 단계에서는 프록시(proxy) 서버를 설정 (`vite.config.js`, `webpack-dev-server`, Nginx 등)

## HTTP에서 쿠키와 세션의 차이는 무엇인가?

쿠키는 브라우저에 저장되는 작은 데이터로, 클라이언트가 서버에 매번 자동으로 전송합니다. 세션은 서버가 사용자 정보를 저장하고, 브라우저에는 세션 ID만 쿠키로 남겨서 식별합니다. 즉, 쿠키는 클라이언트 중심, 세션은 서버 중심 상태 유지 방식입니다. 보안 측면에서는 세션이 더 안전하지만 서버 자원을 소모한다는 trade-off가 있습니다.

## SPA에서 토큰, Pinia, 쿠키 차이

| 항목 | 쿠키 세션(전통) | 토큰 기반(JWT 등) | Pinia |
| --- | --- | --- | --- |
| 본질 | 서버가 세션 상태 저장 | 무상태, 토큰으로 신원 증명 | 클라 상태 관리(저장/공유) |
| 확장성 | 세션 공유 필요(Sticky/Redis) | 수평 확장 용이 | 인증 아키텍처와 무관 |
| 저장 위치 | 세션ID in 쿠키 | 토큰 in 메모리/쿠키 | 토큰·유저·권한 등 클라 상태 |
| 보안 이슈 | CSRF | 저장 위치에 따라 XSS/CSRF | XSS 영향(노출 주의) |
| SPA 전송 | 쿠키 자동 전송 | 주로 Authorization 헤더 | 헤더 붙이도록 인터셉터에서 사용 |

## CSRF란 무엇인가?

사용자가 **로그인해 인증이 붙은 상태**를 악용해, **다른 사이트**에서 피해자 브라우저로 하여금 **의도치 않은 요청**(송금, 비밀번호 변경 등)을 **자동으로 보내게 하는 공격**입니다.

핵심은 **쿠키/HTTP 인증 같은 “자동 첨부 자격증명”**이 브라우저에 의해 같이 전송된다는 점이에요.

필요 시 **JSON+커스텀 헤더**로 CORS 프리플라이트 유도

## Referer Header란?

그리고 서버는 referer를 참조함으로써현재 표시 하는웹페이지가 어떤 웹페이지에서 요청되었는지 알수 있으며,어떤 웹사이트나 웹서버에서방문자가왔는지를 파악할수 있는 기능을 referer 를 통해 할수 있다.

## XSS란?

 XSS는 ***크로스 사이트 스크립팅, 즉 사이트 간 스트립팅이라는 이름의 웹 취약점***입니다.

# HTTP Polling

- 클라이언트가 일정 주기(예: 1초, 5초)마다 서버에 요청을 보내서 새 데이터가 있는지 확인하는 방식.

**특징**

- 구현이 매우 간단 (일반적인 HTTP 요청/응답 사용).
- 불필요한 요청이 많아 네트워크/서버 부하 ↑.
- "실시간성"이 부족함 (주기만큼 지연 발생).

## SSE (Server-Sent Events)

**개념**

- 서버 → 클라이언트 **단방향 스트리밍**.
- HTTP 연결을 맺어두고 서버가 이벤트가 생길 때마다 클라이언트로 푸시.

**특징**

- 단방향 (서버 → 클라이언트 전용).
- 텍스트 기반 이벤트 전송 (JSON, 문자열).
- 브라우저 표준 지원 (`EventSource` API).
- 연결이 끊기면 자동 재연결 지원.

## WebSocket

**개념**

- 클라이언트와 서버 간에 **상시 연결을 유지하며 양방향 통신**을 지원하는 프로토콜.

**특징**

- 양방향 (클라이언트 ↔ 서버 모두 전송 가능).
- 텍스트/바이너리 데이터 모두 지원.
- 실시간성이 뛰어남 (채팅, 게임, 주식 시세).
- 별도의 서버 설정 필요 (예: Node.js `ws`, Spring STOMP 등).

| 방식 | 연결 유지 | 방향 | 장점 | 단점 | 대표 사용 사례 |
| --- | --- | --- | --- | --- | --- |
| **HTTP Polling** | ❌ 없음 | 단방향 (Client → Server 요청) | 구현 쉬움 | 요청 낭비, 지연 발생 | 간단한 상태 체크 |
| **SSE** | ✅ 유지 (HTTP 스트리밍) | 단방향 (Server → Client) | 브라우저 지원, 자동 재연결 | 클라이언트 → 서버 전송 불가, 텍스트만 | 뉴스, 알림, 모니터링 |
| **WebSocket** | ✅ 유지 (독립 프로토콜) | 양방향 | 실시간, 바이너리 지원 | 서버 부담, 프록시/방화벽 문제 가능 | 채팅, 게임, 주식, IoT |

[fecth와 XHR](HTTP%20HTTPS/fecth%EC%99%80%20XHR%20296cee38e89a80ecaa90d8dc17defcea.md)